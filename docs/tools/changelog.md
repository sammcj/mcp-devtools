# Generate Changelog Tool

The `generate_changelog` tool automatically generates changelogs from local Git repositories using commit history analysis. It analyses git repositories and creates structured changelogs based on commit patterns and semantic versioning.

**Note:** This tool is disabled by default. To enable it, set the `ENABLE_ADDITIONAL_TOOLS` environment variable to include `generate_changelog`.

## Overview

This tool provides AI agents with the ability to:
- Generate changelogs from local git commit history between tags/commits
- Automatically categorise changes based on conventional commit patterns
- Support automatic semver version speculation based on change types
- Export changelogs in markdown and JSON formats
- Work with any local git repository
- Optional GitHub integration for enhanced metadata and URLs

## Quick Start

First, enable the tool by setting the environment variable:
```bash
ENABLE_ADDITIONAL_TOOLS="generate_changelog"
```

Then use the tool:
```json
{
  "name": "generate_changelog",
  "arguments": {
    "repository_path": "/Users/username/my-project"
  }
}
```

## Parameters

### Required Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `repository_path` | string | Absolute path to local Git repository (e.g., `/Users/username/project`) |

### Optional Parameters

| Parameter                   | Type    | Default       | Description                                                                    |
|-----------------------------|---------|---------------|--------------------------------------------------------------------------------|
| `since_tag`                 | string  | *auto-detect* | Starting git tag/commit for changelog range                                    |
| `until_tag`                 | string  | `HEAD`        | Ending git tag/commit for changelog range                                      |
| `output_format`             | enum    | `markdown`    | Changelog output format (`markdown` or `json`)                                 |
| `speculate_next_version`    | boolean | `false`       | Predict the next semantic version based on change types                        |
| `enable_github_integration` | boolean | `false`       | Enable GitHub integration for enhanced changelog generation with PR/issue data |
| `title`                     | string  | `Changelog`   | Title for the changelog document                                               |
| `output_file`               | string  | *none*        | Optional file path to save changelog output                                    |

## Examples

### Basic Usage

Generate a changelog for a repository:

```json
{
  "name": "generate_changelog",
  "arguments": {
    "repository_path": "/Users/username/my-project"
  }
}
```

### Version Range

Generate changelog between specific versions:

```json
{
  "name": "generate_changelog",
  "arguments": {
    "repository_path": "/Users/username/my-project",
    "since_tag": "v2.0.0",
    "until_tag": "v2.1.0",
    "title": "What's New in v2.1.0"
  }
}
```

### JSON Output with Version Speculation

Get structured JSON output with next version prediction:

```json
{
  "name": "generate_changelog",
  "arguments": {
    "repository_path": "/Users/username/my-project",
    "output_format": "json",
    "speculate_next_version": true
  }
}
```

### Save to File

Generate and save changelog to a file:

```json
{
  "name": "generate_changelog",
  "arguments": {
    "repository_path": "/Users/username/my-project",
    "output_file": "/Users/username/my-project/CHANGELOG.md",
    "title": "Release Notes",
    "since_tag": "v1.0.0"
  }
}
```

### GitHub Integration

Generate an enhanced changelog with GitHub URLs and metadata:

```json
{
  "name": "generate_changelog",
  "arguments": {
    "repository_path": "/Users/username/my-project",
    "enable_github_integration": true,
    "output_format": "markdown",
    "title": "Release Notes"
  }
}
```

**Note**: GitHub integration requires the `GITHUB_TOKEN` environment variable to be set.

## Output Formats

### Markdown Format

The markdown format creates human-readable documentation with:
- Hierarchical structure with version and date information
- Changes grouped by type (Breaking Changes, Features, Bug Fixes, etc.)
- Commit information and author attribution

Example output:
```markdown
# Changelog

## v1.1.0 - 2024-01-15

### Added Features

- Add dark mode support (commit a1b2c3d by @user)
- Implement user preferences (commit e5f6g7h by @developer)

### Bug Fixes

- Fix login redirect issue (commit i9j0k1l by @maintainer)

---
*Generated by MCP DevTools generate_changelog tool*
```

### JSON Format

The JSON format provides structured data for programmatic processing:

```json
{
  "content": "# Changelog\n\n## v1.1.0...",
  "format": "markdown",
  "version_range": "v1.0.0..v1.1.0",
  "change_count": 15,
  "current_version": "v1.1.0",
  "next_version": "v1.2.0",
  "repository_url": "",
  "changes_url": "",
  "output_file": "/path/to/CHANGELOG.md",
  "generation_time": "2024-01-15T10:30:00Z",
  "repository_path": "/Users/username/my-project"
}
```

## Repository Requirements

- Must be a valid git repository (contains `.git` directory)
- Must have commit history for changelog generation
- Works from any subdirectory within a git repository

## Commit Pattern Recognition

The tool categorises changes based on commit message patterns:

| Change Type             | Commit Patterns                           | Semver Impact | Description               |
|-------------------------|-------------------------------------------|---------------|---------------------------|
| **Breaking Changes**    | `breaking:`, `feat!`, `fix!`, `BREAKING:` | Major         | API breaking changes      |
| **Security Fixes**      | `security:`, `sec:`, `vulnerability`      | Patch         | Security-related fixes    |
| **Added Features**      | `feat:`, `feature:`, `add:`, `new:`       | Minor         | New functionality         |
| **Bug Fixes**           | `fix:`, `bug:`, `repair:`, `hotfix:`      | Patch         | Bug fixes and corrections |
| **Deprecated Features** | `deprecate:`, `deprecated:`               | Minor         | Feature deprecations      |
| **Removed Features**    | `remove:`, `delete:`, `drop:`             | Major         | Removed functionality     |
| **Other Changes**       | *(any other format)*                      | None          | General changes           |

## Version Speculation

When `speculate_next_version` is enabled, the tool analyses change types to predict the next semantic version:

- **Major**: Breaking changes or removed features
- **Minor**: New features or deprecations (if no major changes)
- **Patch**: Bug fixes or security fixes (if no major/minor changes)

## Common Workflows

### Release Preparation

```json
{
  "name": "generate_changelog",
  "arguments": {
    "repository_path": "/Users/username/my-project",
    "speculate_next_version": true,
    "output_file": "/Users/username/my-project/CHANGELOG.md"
  }
}
```

### Version-Specific Changelog

```json
{
  "name": "generate_changelog",
  "arguments": {
    "repository_path": "/Users/username/my-project",
    "since_tag": "v2.0.0",
    "until_tag": "v2.1.0",
    "output_format": "markdown",
    "title": "v2.1.0 Release Notes"
  }
}
```

### CI/CD Integration

```json
{
  "name": "generate_changelog",
  "arguments": {
    "repository_path": "/Users/username/my-project",
    "output_format": "json",
    "output_file": "/Users/username/my-project/changelog.json",
    "timeout_minutes": 10
  }
}
```

## Troubleshooting

### Common Issues

**"Repository path is not a git repository"**
- Ensure the path points to a directory containing a `.git` folder
- Run `git init` if needed or verify the path is correct

**"Repository path does not exist"**
- Verify the absolute path is correct
- Ensure the directory exists and is accessible

**"No changes found between tags"**
- Check that specified tags exist (`git tag -l`)
- Verify there are commits between the tags (`git log tag1..tag2`)

**"Timeout errors with large repositories"**
- Focus on smaller commit ranges using `since_tag` and `until_tag` parameters
- The tool has a 2-minute timeout limit for performance

## Configuration

### Repository Setup

For best results, ensure your git repository follows these practices:

1. **Conventional Commits**: Use conventional commit message format
2. **Descriptive Messages**: Clear, concise commit messages
3. **Semantic Versioning**: Use semantic version tags (`v1.2.3`)
4. **Regular Tagging**: Tag releases consistently for better range detection

### GitHub Integration

To enable GitHub integration features, set the following environment variable:

| Environment Variable | Required | Description | Default |
|---------------------|----------|-------------|---------|
| `GITHUB_TOKEN` | Yes | GitHub personal access token with repo access | - |

#### GitHub Token Setup

1. Go to GitHub Settings → Developer settings → Personal access tokens
2. Generate a new token with `repo` scope
3. Set the token as an environment variable:
   ```bash
   export GITHUB_TOKEN=your_token_here
   ```

#### GitHub Integration Features

When enabled, GitHub integration provides:
- Automatic GitHub URLs for tags and commit ranges in changelog output
- Enhanced repository metadata for better documentation
- Future: Enhanced commit messages with PR/issue links (planned)
- Future: Better change categorisation based on GitHub labels (planned)

## Limitations

- **Local Only**: Works only with local filesystem paths, not URLs
- **Git Dependency**: Must be run on a git repository
- **Commit Quality**: Effectiveness depends on commit message quality
- **Pattern Matching**: Uses heuristic pattern matching for change categorisation
- **GitHub Integration**: Currently provides URL enhancement, full PR/issue metadata enhancement is planned for future releases

## Integration with Other Tools

The changelog tool works well with other MCP DevTools in release workflows:

1. Generate changelog from local repository
2. Generate SBOM for security analysis
3. Scan for vulnerabilities
4. Prepare release documentation

## Best Practices

1. **Use Absolute Paths**: Always provide absolute paths for reliability
2. **Conventional Commits**: Use conventional commit format for better categorisation
3. **Regular Generation**: Generate changelogs regularly, not just at release time
4. **Version Control**: Commit generated changelogs to version control
5. **Automation**: Integrate into CI/CD pipelines for automated documentation
6. **Tag Consistently**: Use consistent tagging strategy for version ranges
