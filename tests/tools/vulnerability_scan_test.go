package tools_test

import (
	"context"
	"os"
	"path/filepath"
	"sync"
	"testing"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/sammcj/mcp-devtools/internal/tools/vulnerabilityscan"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestVulnerabilityScanTool_Definition(t *testing.T) {
	tool := &vulnerabilityscan.VulnerabilityScanTool{}

	definition := tool.Definition()

	assert.Equal(t, "vulnerability_scan", definition.Name)
	assert.Contains(t, definition.Description, "vulnerabilities")
	// Note: Security environment variables were removed from descriptions

	// Check that source parameter is required
	sourceParam := findParameter(definition.InputSchema.Properties, "source")
	require.NotNil(t, sourceParam)
	assert.Contains(t, definition.InputSchema.Required, "source")

	// Check optional parameters exist with proper defaults
	formatParam := findParameter(definition.InputSchema.Properties, "output_format")
	require.NotNil(t, formatParam)
	assert.Equal(t, "json", formatParam.Default)

	onlyFixedParam := findParameter(definition.InputSchema.Properties, "only_fixed")
	require.NotNil(t, onlyFixedParam)
	assert.Equal(t, false, onlyFixedParam.Default)

	// Verify that removed parameters are no longer present
	sortByParam := findParameter(definition.InputSchema.Properties, "sort_by")
	assert.Nil(t, sortByParam, "sort_by parameter should have been removed")

	timeoutParam := findParameter(definition.InputSchema.Properties, "timeout_minutes")
	assert.Nil(t, timeoutParam, "timeout_minutes parameter should have been removed")

	failSeverityParam := findParameter(definition.InputSchema.Properties, "fail_on_severity")
	assert.Nil(t, failSeverityParam, "fail_on_severity parameter should have been removed")
}

func TestVulnerabilityScanTool_Execute_ToolEnabled(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr) // Avoid stdout in tests
	cache := &sync.Map{}

	// Use absolute path for testing since tools require absolute paths for security
	args := map[string]interface{}{
		"source": getCurrentDir(),
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// The tool should execute successfully and generate a real vulnerability report
	result, err := tool.Execute(ctx, logger, cache, args)

	require.NoError(t, err)
	require.NotNil(t, result)
	require.True(t, len(result.Content) > 0, "Expected content in result")
	textContent, ok := mcp.AsTextContent(result.Content[0])
	require.True(t, ok, "Expected TextContent type")
	// Should contain actual vulnerability scan content
	assert.Contains(t, textContent.Text, "vulnerability_report_format")
}

func TestVulnerabilityScanTool_Execute_InvalidParameters(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}
	ctx := context.Background()

	tests := []struct {
		name     string
		args     map[string]interface{}
		errorMsg string
	}{
		{
			name:     "missing source",
			args:     map[string]interface{}{},
			errorMsg: "missing or invalid required parameter: source",
		},
		{
			name:     "empty source",
			args:     map[string]interface{}{"source": ""},
			errorMsg: "missing or invalid required parameter: source",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := tool.Execute(ctx, logger, cache, tt.args)
			assert.Error(t, err)
			assert.Nil(t, result)
			assert.Contains(t, err.Error(), tt.errorMsg)
		})
	}
}

func TestVulnerabilityScanTool_Execute_ValidCurrentDirectory(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}

	args := map[string]interface{}{
		"source":        getCurrentDir(),
		"output_format": "json",
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	result, err := tool.Execute(ctx, logger, cache, args)

	// Should succeed with real vulnerability scanning implementation
	require.NoError(t, err)
	require.NotNil(t, result)

	// Content should be actual vulnerability report JSON
	require.True(t, len(result.Content) > 0, "Expected content in result")
	textContent, ok := mcp.AsTextContent(result.Content[0])
	require.True(t, ok, "Expected TextContent type")
	assert.Contains(t, textContent.Text, "vulnerability_report_format")
	assert.Contains(t, textContent.Text, "vulnerabilities")
	// Should contain real scan metadata, not placeholder
	assert.Contains(t, textContent.Text, "scan_metadata")
}

func TestVulnerabilityScanTool_Execute_SBOMInput(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}

	// Create a temporary SBOM file
	tempDir, err := os.MkdirTemp("", "vuln_test_")
	require.NoError(t, err)
	defer func() { _ = os.RemoveAll(tempDir) }()

	sbomFile := filepath.Join(tempDir, "test.sbom.json")
	sbomContent := `{"sbom": {"format": "syft-json", "packages": []}}`
	err = os.WriteFile(sbomFile, []byte(sbomContent), 0644)
	require.NoError(t, err)

	args := map[string]interface{}{
		"source": "sbom:" + sbomFile,
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	result, err := tool.Execute(ctx, logger, cache, args)

	require.NoError(t, err)
	require.NotNil(t, result)

	require.True(t, len(result.Content) > 0, "Expected content in result")
	textContent, ok := mcp.AsTextContent(result.Content[0])
	require.True(t, ok, "Expected TextContent type")
	assert.Contains(t, textContent.Text, "vulnerability_report_format")
	assert.Contains(t, textContent.Text, sbomFile)
}

func TestVulnerabilityScanTool_Execute_PackageURLInput(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}

	args := map[string]interface{}{
		"source":        "pkg:npm/lodash@4.17.21",
		"output_format": "table",
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	result, err := tool.Execute(ctx, logger, cache, args)

	require.NoError(t, err)
	require.NotNil(t, result)

	require.True(t, len(result.Content) > 0, "Expected content in result")
	textContent, ok := mcp.AsTextContent(result.Content[0])
	require.True(t, ok, "Expected TextContent type")
	assert.Contains(t, textContent.Text, "lodash@4.17.21")
	assert.Contains(t, textContent.Text, "package")
}

func TestVulnerabilityScanTool_Execute_WithOutputFile(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}

	args := map[string]interface{}{
		"source":      getCurrentDir(),
		"output_file": filepath.Join(getCurrentDir(), "test-vulns.json"), // Absolute path
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	result, err := tool.Execute(ctx, logger, cache, args)

	require.NoError(t, err)
	require.NotNil(t, result)

	// Check that output file was created
	_, err = os.Stat("test-vulns.json")
	if err == nil {
		// Clean up created file
		_ = os.Remove("test-vulns.json")
	}
}

func TestVulnerabilityScanTool_Execute_SBOMNotFound(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}

	args := map[string]interface{}{
		"source": "sbom:/nonexistent/path/sbom.json",
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	result, err := tool.Execute(ctx, logger, cache, args)

	assert.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "SBOM file does not exist")
}

func TestVulnerabilityScanTool_ValidateSourcePath_Security(t *testing.T) {
	tool := &vulnerabilityscan.VulnerabilityScanTool{}

	tests := []struct {
		name     string
		source   string
		wantErr  bool
		errorMsg string
	}{
		{
			name:    "current directory",
			source:  getCurrentDir(),
			wantErr: false,
		},
		{
			name:     "path traversal attempt",
			source:   "../../../etc",
			wantErr:  true,
			errorMsg: "does not exist",
		},
		{
			name:     "non-existent path",
			source:   "/nonexistent/path",
			wantErr:  true,
			errorMsg: "does not exist",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			logger := logrus.New()
			logger.SetOutput(os.Stderr)
			cache := &sync.Map{}

			args := map[string]interface{}{
				"source": tt.source,
			}

			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()

			_, err := tool.Execute(ctx, logger, cache, args)

			if tt.wantErr {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestVulnerabilityScanTool_ProvideExtendedInfo(t *testing.T) {
	tool := &vulnerabilityscan.VulnerabilityScanTool{}

	extendedInfo := tool.ProvideExtendedInfo()

	require.NotNil(t, extendedInfo)
	assert.NotEmpty(t, extendedInfo.Examples)
	assert.NotEmpty(t, extendedInfo.CommonPatterns)
	assert.NotEmpty(t, extendedInfo.Troubleshooting)
	assert.NotEmpty(t, extendedInfo.ParameterDetails)
	assert.NotEmpty(t, extendedInfo.WhenToUse)
	assert.NotEmpty(t, extendedInfo.WhenNotToUse)

	// Check that examples have required fields
	for i, example := range extendedInfo.Examples {
		assert.NotEmpty(t, example.Description, "Example %d should have description", i)
		assert.NotEmpty(t, example.Arguments, "Example %d should have arguments", i)
		assert.NotEmpty(t, example.ExpectedResult, "Example %d should have expected result", i)
	}

	// Check that troubleshooting tips have required fields
	for i, tip := range extendedInfo.Troubleshooting {
		assert.NotEmpty(t, tip.Problem, "Troubleshooting tip %d should have problem", i)
		assert.NotEmpty(t, tip.Solution, "Troubleshooting tip %d should have solution", i)
	}
}

func TestVulnerabilityScanTool_ParameterValidation(t *testing.T) {
	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}
	ctx := context.Background()

	// Test valid parameter combinations
	validTests := []struct {
		name string
		args map[string]interface{}
	}{
		{
			name: "all optional params",
			args: map[string]interface{}{
				"source":        func() string { cwd, _ := os.Getwd(); return cwd }(),
				"output_format": "sarif",
				"only_fixed":    true,
			},
		},
		{
			name: "minimal params",
			args: map[string]interface{}{
				"source": func() string { cwd, _ := os.Getwd(); return cwd }(),
			},
		},
	}

	for _, tt := range validTests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := tool.Execute(ctx, logger, cache, tt.args)
			assert.NoError(t, err)
			assert.NotNil(t, result)
		})
	}
}
