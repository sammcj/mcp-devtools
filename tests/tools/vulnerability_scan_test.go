//go:build sbom_vuln_tools
// +build sbom_vuln_tools

package tools_test

import (
	"context"
	"os"
	"sync"
	"testing"
	"time"

	"github.com/sammcj/mcp-devtools/internal/tools/vulnerabilityscan"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestVulnerabilityScanTool_Definition(t *testing.T) {
	tool := &vulnerabilityscan.VulnerabilityScanTool{}

	definition := tool.Definition()

	assert.Equal(t, "vulnerability_scan", definition.Name)
	assert.Contains(t, definition.Description, "vulnerabilities")
	// Note: Security environment variables were removed from descriptions

	// Check that source parameter is required
	sourceParam := findParameter(definition.InputSchema.Properties, "source")
	require.NotNil(t, sourceParam)
	assert.Contains(t, definition.InputSchema.Required, "source")

	// Check optional parameters exist with proper defaults
	formatParam := findParameter(definition.InputSchema.Properties, "output_format")
	require.NotNil(t, formatParam)
	assert.Equal(t, "json", formatParam.Default)

	onlyFixedParam := findParameter(definition.InputSchema.Properties, "only_fixed")
	require.NotNil(t, onlyFixedParam)
	assert.Equal(t, false, onlyFixedParam.Default)

	// Verify that removed parameters are no longer present
	sortByParam := findParameter(definition.InputSchema.Properties, "sort_by")
	assert.Nil(t, sortByParam, "sort_by parameter should have been removed")

	timeoutParam := findParameter(definition.InputSchema.Properties, "timeout_minutes")
	assert.Nil(t, timeoutParam, "timeout_minutes parameter should have been removed")

	failSeverityParam := findParameter(definition.InputSchema.Properties, "fail_on_severity")
	assert.Nil(t, failSeverityParam, "fail_on_severity parameter should have been removed")
}

func TestVulnerabilityScanTool_Execute_ToolDisabled(t *testing.T) {
	// Ensure vulnerability scan tool is disabled by default
	_ = os.Unsetenv("ENABLE_ADDITIONAL_TOOLS")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}

	args := map[string]interface{}{
		"source":      "/tmp", // Dummy path
		"output_file": "/tmp/test-vuln.json",
	}

	ctx := context.Background()

	// Tool should fail immediately when disabled
	result, err := tool.Execute(ctx, logger, cache, args)

	require.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "vulnerability scan tool is not enabled")
}

func TestVulnerabilityScanTool_Execute_InvalidParameters(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}
	ctx := context.Background()

	tests := []struct {
		name     string
		args     map[string]interface{}
		errorMsg string
	}{
		{
			name:     "missing source",
			args:     map[string]interface{}{},
			errorMsg: "missing or invalid required parameter: source",
		},
		{
			name:     "empty source",
			args:     map[string]interface{}{"source": ""},
			errorMsg: "missing or invalid required parameter: source",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := tool.Execute(ctx, logger, cache, tt.args)
			assert.Error(t, err)
			assert.Nil(t, result)
			assert.Contains(t, err.Error(), tt.errorMsg)
		})
	}
}

func TestVulnerabilityScanTool_Execute_ParameterValidation(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")
	defer func() { _ = os.Unsetenv("ENABLE_ADDITIONAL_TOOLS") }()

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}
	ctx := context.Background()

	// Test with relative path (should fail fast)
	args := map[string]interface{}{
		"source":      "./relative/path",
		"output_file": "/tmp/test-vuln.json",
	}

	result, err := tool.Execute(ctx, logger, cache, args)
	require.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "source path must be absolute")
}

func TestVulnerabilityScanTool_Execute_SBOMPathValidation(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")
	defer func() { _ = os.Unsetenv("ENABLE_ADDITIONAL_TOOLS") }()

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}
	ctx := context.Background()

	// Test with relative SBOM path (should fail fast)
	args := map[string]interface{}{
		"source":      "sbom:./relative/path.json",
		"output_file": "/tmp/test-vuln.json",
	}

	result, err := tool.Execute(ctx, logger, cache, args)
	require.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "SBOM file path must be absolute")

	// Test with non-existent SBOM file (should fail fast)
	args = map[string]interface{}{
		"source":      "sbom:/nonexistent/file.json",
		"output_file": "/tmp/test-vuln.json",
	}

	result, err = tool.Execute(ctx, logger, cache, args)
	require.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "SBOM file does not exist")
}

func TestVulnerabilityScanTool_Execute_PackageURLInput(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}

	args := map[string]interface{}{
		"source":        "pkg:npm/lodash@4.17.21",
		"output_format": "table",
		"output_file":   "/tmp/test-vuln.json",
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	result, err := tool.Execute(ctx, logger, cache, args)

	// Should fail as package URL input is not fully implemented
	require.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "package URL input requires more complex implementation")
}

func TestVulnerabilityScanTool_Execute_RelativeOutputFile(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")
	defer func() { _ = os.Unsetenv("ENABLE_ADDITIONAL_TOOLS") }()

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}
	ctx := context.Background()

	// Test with relative output file path (should fail fast)
	args := map[string]interface{}{
		"source":      getCurrentDir(),
		"output_file": "./relative/output.json", // Relative path
	}

	result, err := tool.Execute(ctx, logger, cache, args)
	require.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "output_file path must be absolute")
}

func TestVulnerabilityScanTool_Execute_SBOMNotFound(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}

	args := map[string]interface{}{
		"source":      "sbom:/nonexistent/path/sbom.json",
		"output_file": "/tmp/test-vuln.json",
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	result, err := tool.Execute(ctx, logger, cache, args)

	assert.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "SBOM file does not exist")
}

func TestVulnerabilityScanTool_ValidateSourcePath_Security(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")
	defer func() { _ = os.Unsetenv("ENABLE_ADDITIONAL_TOOLS") }()

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}
	ctx := context.Background()

	// Test path traversal (should fail fast during parameter validation)
	args := map[string]interface{}{
		"source":      "../../../etc",
		"output_file": "/tmp/test-vuln.json",
	}
	result, err := tool.Execute(ctx, logger, cache, args)
	require.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "source path must be absolute")

	// Test non-existent path (should fail fast during source validation)
	args = map[string]interface{}{
		"source":      "/nonexistent/path/12345",
		"output_file": "/tmp/test-vuln.json",
	}
	result, err = tool.Execute(ctx, logger, cache, args)
	require.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "source path does not exist")
}

func TestVulnerabilityScanTool_ProvideExtendedInfo(t *testing.T) {
	tool := &vulnerabilityscan.VulnerabilityScanTool{}

	extendedInfo := tool.ProvideExtendedInfo()

	require.NotNil(t, extendedInfo)
	assert.NotEmpty(t, extendedInfo.Examples)
	assert.NotEmpty(t, extendedInfo.CommonPatterns)
	assert.NotEmpty(t, extendedInfo.Troubleshooting)
	assert.NotEmpty(t, extendedInfo.ParameterDetails)
	assert.NotEmpty(t, extendedInfo.WhenToUse)
	assert.NotEmpty(t, extendedInfo.WhenNotToUse)

	// Check that examples have required fields
	for i, example := range extendedInfo.Examples {
		assert.NotEmpty(t, example.Description, "Example %d should have description", i)
		assert.NotEmpty(t, example.Arguments, "Example %d should have arguments", i)
		assert.NotEmpty(t, example.ExpectedResult, "Example %d should have expected result", i)
	}

	// Check that troubleshooting tips have required fields
	for i, tip := range extendedInfo.Troubleshooting {
		assert.NotEmpty(t, tip.Problem, "Troubleshooting tip %d should have problem", i)
		assert.NotEmpty(t, tip.Solution, "Troubleshooting tip %d should have solution", i)
	}
}

func TestVulnerabilityScanTool_FastParameterTests(t *testing.T) {
	// Enable the vulnerability scan tool for testing
	_ = os.Setenv("ENABLE_ADDITIONAL_TOOLS", "vulnerability_scan")
	defer func() { _ = os.Unsetenv("ENABLE_ADDITIONAL_TOOLS") }()

	tool := &vulnerabilityscan.VulnerabilityScanTool{}
	logger := logrus.New()
	logger.SetOutput(os.Stderr)
	cache := &sync.Map{}
	ctx := context.Background()

	// Test package URL input (should fail fast with not implemented error)
	args := map[string]interface{}{
		"source":      "pkg:npm/lodash@4.17.21",
		"output_file": "/tmp/test-vuln.json",
	}
	result, err := tool.Execute(ctx, logger, cache, args)
	require.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "package URL input requires more complex implementation")
}
