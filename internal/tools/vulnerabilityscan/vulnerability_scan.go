package vulnerabilityscan

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	gologger "github.com/anchore/go-logger"
	"github.com/anchore/go-logger/adapter/discard"
	logrusadapter "github.com/anchore/go-logger/adapter/logrus"
	"github.com/anchore/grype/grype"
	"github.com/anchore/grype/grype/db/v6/distribution"
	"github.com/anchore/grype/grype/db/v6/installation"
	"github.com/anchore/grype/grype/match"
	grypePkg "github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/syft/syft"
	"github.com/anchore/syft/syft/format"
	"github.com/anchore/syft/syft/sbom"
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/sammcj/mcp-devtools/internal/registry"
	"github.com/sammcj/mcp-devtools/internal/security"
	"github.com/sammcj/mcp-devtools/internal/tools"
	"github.com/sirupsen/logrus"
)

// VulnerabilityScanTool implements vulnerability scanning using Anchore Grype
type VulnerabilityScanTool struct{}

// Ensure we implement the interfaces
var _ tools.Tool = (*VulnerabilityScanTool)(nil)
var _ tools.ExtendedHelpProvider = (*VulnerabilityScanTool)(nil)

// init registers the vulnerability scan tool
func init() {
	registry.Register(&VulnerabilityScanTool{})
}

// Definition returns the tool's definition for MCP registration
func (t *VulnerabilityScanTool) Definition() mcp.Tool {
	return mcp.NewTool(
		"vulnerability_scan",
		mcp.WithDescription("Scan source code projects and their dependencies for known vulnerabilities using Grype. Analyses current project or SBOM files for security risks. Always saves to specified file and returns summary."),

		// Required parameters
		mcp.WithString("source",
			mcp.Required(),
			mcp.Description("Source to scan: absolute directory path (/path/to/project), SBOM file (sbom:/absolute/path/to/sbom.json), or package URL (pkg:npm/lodash@4.17.21). Directory scanning will first generate SBOM then scan for vulnerabilities. Must be absolute path."),
		),

		// Optional parameters with sensible defaults
		mcp.WithString("output_format",
			mcp.Description("Vulnerability report format: 'json' (comprehensive data), 'table' (human readable), 'cyclonedx-json' (toolchain integration), 'sarif' (IDE integration)"),
			mcp.Enum("json", "table", "cyclonedx-json", "sarif"),
			mcp.DefaultString("json"),
		),
		mcp.WithBoolean("only_fixed",
			mcp.Description("Only report vulnerabilities that have confirmed fixes available"),
			mcp.DefaultBool(false),
		),
		mcp.WithString("output_file",
			mcp.Required(),
			mcp.Description("Absolute file path to save vulnerability report. Creates directories as needed."),
		),
	)
}

// Execute executes the vulnerability scan tool
func (t *VulnerabilityScanTool) Execute(ctx context.Context, logger *logrus.Logger, cache *sync.Map, args map[string]interface{}) (*mcp.CallToolResult, error) {
	// Check if vulnerability scan tool is enabled (disabled by default)
	if !tools.IsToolEnabled("vulnerability_scan") {
		return nil, fmt.Errorf("vulnerability scan tool is not enabled. Set ENABLE_ADDITIONAL_TOOLS environment variable to include 'vulnerability_scan'")
	}

	// Configure Syft and Grype logging to prevent stdout/stderr interference in stdio mode
	// Check if we're likely in stdio mode by checking log level (ErrorLevel = stdio mode)
	if logger.Level == logrus.ErrorLevel {
		// In stdio mode, disable library logging completely to prevent MCP protocol interference
		syft.SetLogger(discard.New())
		grype.SetLogger(discard.New())
	} else {
		// In non-stdio mode, allow minimal library logging to stderr
		stderrLogger, err := logrusadapter.New(logrusadapter.Config{
			EnableConsole: true,
			Level:         gologger.WarnLevel,
		})
		if err != nil {
			// Fallback to discard if logger creation fails
			syft.SetLogger(discard.New())
			grype.SetLogger(discard.New())
		} else {
			// Type assert to Controller to access SetOutput method
			if ctrl, ok := stderrLogger.(gologger.Controller); ok {
				ctrl.SetOutput(os.Stderr)
			}
			syft.SetLogger(stderrLogger)
			grype.SetLogger(stderrLogger)
		}
	}

	// Parse and validate parameters
	request, err := t.parseRequest(args)
	if err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	logger.WithFields(logrus.Fields{
		"source":        request.Source,
		"output_format": request.OutputFormat,
		"only_fixed":    request.OnlyFixed,
		"output_file":   request.OutputFile,
	}).Debug("Vulnerability scan parameters")

	// Create context with reasonable timeout (5 minutes)
	cmdCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
	defer cancel()

	// Execute vulnerability scanning
	response, err := t.executeGrype(cmdCtx, request, logger)
	if err != nil {
		return nil, fmt.Errorf("vulnerability scan failed: %w", err)
	}

	logger.WithFields(logrus.Fields{
		"source":              request.Source,
		"output_format":       request.OutputFormat,
		"vulnerability_count": response.VulnerabilityCount,
		"highest_severity":    response.HighestSeverity,
		"output_file":         response.OutputFile,
	}).Info("Vulnerability scan completed successfully")

	// Create summary report
	summary := fmt.Sprintf("Vulnerability scan completed successfully!\n\nDetails:\n- Source: %s\n- Format: %s\n- Vulnerabilities found: %d\n- Ignored/filtered: %d\n- Highest severity: %s\n- Report saved to: %s\n\nSeverity Breakdown:\n",
		response.Source, response.Format, response.VulnerabilityCount, response.IgnoredCount, response.HighestSeverity, response.OutputFile)

	for severity, count := range response.SeverityBreakdown {
		if count > 0 {
			summary += fmt.Sprintf("- %s: %d\n", strings.ToUpper(severity[:1])+severity[1:], count)
		}
	}

	summary += "\nThe vulnerability report has been saved to the specified file and is ready for review and remediation planning."

	// Add security notice to summary if present
	if response.SecurityNotice != "" {
		summary += "\n\n" + response.SecurityNotice
	}

	return mcp.NewToolResultText(summary), nil
}

// VulnerabilityScanRequest represents the parsed request parameters
type VulnerabilityScanRequest struct {
	Source       string `json:"source"`
	OutputFormat string `json:"output_format"`
	OnlyFixed    bool   `json:"only_fixed"`
	OutputFile   string `json:"output_file"`
}

// VulnerabilityScanResponse represents the vulnerability scan response
type VulnerabilityScanResponse struct {
	Content            string         `json:"content"`
	Format             string         `json:"format"`
	VulnerabilityCount int            `json:"vulnerability_count"`
	IgnoredCount       int            `json:"ignored_count"`
	Source             string         `json:"source"`
	OutputFile         string         `json:"output_file,omitempty"`
	SeverityBreakdown  map[string]int `json:"severity_breakdown"`
	HighestSeverity    string         `json:"highest_severity"`
	SecurityNotice     string         `json:"security_notice,omitempty"`
}

// parseRequest parses and validates the tool arguments
func (t *VulnerabilityScanTool) parseRequest(args map[string]interface{}) (*VulnerabilityScanRequest, error) {
	// Parse source (required)
	source, ok := args["source"].(string)
	if !ok || source == "" {
		return nil, fmt.Errorf("missing or invalid required parameter: source")
	}

	request := &VulnerabilityScanRequest{
		Source:       strings.TrimSpace(source),
		OutputFormat: "json", // Default
		OnlyFixed:    false,  // Default
	}

	// Parse output_format (optional)
	if outputFormatRaw, ok := args["output_format"].(string); ok {
		request.OutputFormat = outputFormatRaw
	}

	// Parse only_fixed (optional)
	if onlyFixedRaw, ok := args["only_fixed"].(bool); ok {
		request.OnlyFixed = onlyFixedRaw
	}

	// Parse output_file (required)
	outputFile, ok := args["output_file"].(string)
	if !ok || outputFile == "" {
		return nil, fmt.Errorf("missing or invalid required parameter: output_file")
	}
	request.OutputFile = strings.TrimSpace(outputFile)

	// Validate paths are absolute
	if err := t.validateAbsolutePaths(request); err != nil {
		return nil, err
	}

	// Security checks for file access
	if err := t.validateSecurityAccess(request); err != nil {
		return nil, err
	}

	return request, nil
}

// validateAbsolutePaths validates that source and output_file paths are absolute
func (t *VulnerabilityScanTool) validateAbsolutePaths(request *VulnerabilityScanRequest) error {
	// Validate source path (unless it's a package URL or SBOM reference)
	if !strings.HasPrefix(request.Source, "pkg:") && !strings.HasPrefix(request.Source, "sbom:") {
		if !filepath.IsAbs(request.Source) {
			return fmt.Errorf("source path must be absolute: %s", request.Source)
		}
	} else if after, ok := strings.CutPrefix(request.Source, "sbom:"); ok {
		// For SBOM files, check the path after 'sbom:'
		sbomPath := after
		if !filepath.IsAbs(sbomPath) {
			return fmt.Errorf("SBOM file path must be absolute: %s", sbomPath)
		}
	}

	// Validate output file path is absolute
	if !filepath.IsAbs(request.OutputFile) {
		return fmt.Errorf("output_file path must be absolute: %s", request.OutputFile)
	}

	return nil
}

// validateSecurityAccess performs security validation for file access
func (t *VulnerabilityScanTool) validateSecurityAccess(request *VulnerabilityScanRequest) error {
	// Check security access for source path (unless it's a package URL)
	if !strings.HasPrefix(request.Source, "pkg:") {
		var sourcePath string
		if strings.HasPrefix(request.Source, "sbom:") {
			// For SBOM files, check the path after 'sbom:'
			sourcePath = strings.TrimPrefix(request.Source, "sbom:")
		} else {
			// For directory paths
			sourcePath = request.Source
		}

		// Check file access security for source
		if err := security.CheckFileAccess(sourcePath); err != nil {
			return err
		}
	}

	// Check file access security for output file
	if err := security.CheckFileAccess(request.OutputFile); err != nil {
		return err
	}

	return nil
}

// executeGrype executes Grype to scan for vulnerabilities
func (t *VulnerabilityScanTool) executeGrype(ctx context.Context, request *VulnerabilityScanRequest, logger *logrus.Logger) (*VulnerabilityScanResponse, error) {
	var sbomData *sbom.SBOM
	var err error

	// Handle different source types
	if strings.HasPrefix(request.Source, "sbom:") {
		// SBOM file input - load existing SBOM
		sbomPath := strings.TrimPrefix(request.Source, "sbom:")
		if _, err := os.Stat(sbomPath); err != nil {
			return nil, fmt.Errorf("SBOM file does not exist: %s", sbomPath)
		}

		// Parse existing SBOM file
		logger.WithField("sbom_path", sbomPath).Debug("Loading SBOM file")
		sbomBytes, err := os.ReadFile(sbomPath)
		if err != nil {
			return nil, fmt.Errorf("failed to read SBOM file: %w", err)
		}

		// Use Syft to parse the SBOM file
		sbomReader := strings.NewReader(string(sbomBytes))
		sbomData, _, _, err = format.Decode(sbomReader)
		if err != nil {
			return nil, fmt.Errorf("failed to parse SBOM file: %w", err)
		}

		logger.WithField("package_count", len(sbomData.Artifacts.Packages.Sorted())).Debug("SBOM file loaded successfully")

	} else if strings.HasPrefix(request.Source, "pkg:") {
		// Package URL input - create minimal SBOM from package URL
		packageURL := request.Source
		logger.WithField("package_url", packageURL).Debug("Creating SBOM from package URL")

		// For package URLs, we'll create a minimal SBOM and let Grype handle it
		// This is a simplified approach - in practice, more complex package resolution would be needed
		return nil, fmt.Errorf("package URL input requires more complex implementation - use directory scanning with installed packages instead")

	} else {
		// Directory input - generate SBOM first, then scan
		sourcePath := request.Source
		info, err := os.Stat(sourcePath)
		if err != nil {
			return nil, fmt.Errorf("source path does not exist: %s", sourcePath)
		}
		if !info.IsDir() {
			return nil, fmt.Errorf("source path must be a directory: %s", sourcePath)
		}
		logger.WithField("source_path", sourcePath).Debug("Validated directory source path")

		// Get source using Syft's helper exactly like the working example
		logger.WithField("syft_input", sourcePath).Info("About to call syft.GetSource for vulnerability scan")
		src, err := syft.GetSource(context.Background(), sourcePath, nil)
		if err != nil {
			logger.WithFields(logrus.Fields{
				"error": err.Error(),
				"input": sourcePath,
			}).Error("syft.GetSource failed for vulnerability scan")
			return nil, fmt.Errorf("failed to create source from directory: %w", err)
		}

		// Generate SBOM using Syft
		logger.Debug("Generating SBOM for vulnerability scanning")
		sbomData, err = syft.CreateSBOM(context.Background(), src, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to generate SBOM: %w", err)
		}

		logger.WithField("package_count", len(sbomData.Artifacts.Packages.Sorted())).Debug("SBOM generated for vulnerability scanning")
	}

	// Initialise and update vulnerability database
	logger.Debug("Initialising vulnerability database")
	vulnerabilityProvider, dbStatus, err := t.initialiseVulnerabilityDatabase(logger)
	if err != nil {
		return nil, fmt.Errorf("failed to initialise vulnerability database: %w", err)
	}
	logger.WithField("db_status", dbStatus).Debug("Vulnerability database ready")

	// Perform actual vulnerability scanning with Grype
	logger.Debug("Starting vulnerability scanning with Grype")

	// Create vulnerability matcher
	vulnMatcher := &grype.VulnerabilityMatcher{
		VulnerabilityProvider: vulnerabilityProvider,
	}

	// Get packages from SBOM and convert to Grype package format
	syftPackages := sbomData.Artifacts.Packages.Sorted()
	packages := grypePkg.FromPackages(syftPackages, grypePkg.SynthesisConfig{})
	logger.WithField("package_count", len(packages)).Debug("Found packages for vulnerability scanning")

	// Perform vulnerability matching
	allMatches, ignoredMatches, err := vulnMatcher.FindMatches(packages, grypePkg.Context{})
	if err != nil {
		return nil, fmt.Errorf("vulnerability matching failed: %w", err)
	}

	// Convert to slice for easier processing
	remainingMatches := allMatches.Sorted()

	logger.WithField("found_matches", len(remainingMatches)).WithField("ignored_matches", len(ignoredMatches)).Debug("Vulnerability scanning completed")

	// Filter matches if only_fixed is requested
	if request.OnlyFixed {
		remainingMatches = t.filterFixedVulnerabilities(remainingMatches)
		logger.WithField("fixed_matches", len(remainingMatches)).Debug("Filtered to only fixed vulnerabilities")
	}

	// Format the results
	content, err := t.formatVulnerabilityResults(remainingMatches, request.OutputFormat, sbomData)
	if err != nil {
		return nil, fmt.Errorf("failed to format vulnerability results: %w", err)
	}

	// Calculate severity breakdown and highest severity
	severityBreakdown, highestSeverity := t.analyseSeverities(remainingMatches)

	// Security analysis of vulnerability scan results
	var securityNotice string
	sourceContext := security.SourceContext{
		Tool:        "vulnerability_scan",
		URL:         request.Source,
		ContentType: "vulnerability_report",
	}

	if result, err := security.AnalyseContent(content, sourceContext); err == nil {
		switch result.Action {
		case security.ActionBlock:
			return nil, fmt.Errorf("vulnerability report blocked by security policy [ID: %s]: %s Check with the user if you may use security_override tool with ID %s and justification", result.ID, result.Message, result.ID)
		case security.ActionWarn:
			securityNotice = fmt.Sprintf("Security Warning [ID: %s]: %s Use security_override tool with ID %s if this is intentional.", result.ID, result.Message, result.ID)
			logger.WithField("security_id", result.ID).Warn(result.Message)
		case security.ActionAllow:
			// No action needed for safe content
		}
	} else {
		logger.WithError(err).Debug("Security analysis failed")
	}

	// Always write to file
	if err := t.writeToFile(request.OutputFile, content); err != nil {
		return nil, fmt.Errorf("failed to write to file: %w", err)
	}

	response := &VulnerabilityScanResponse{
		Content:            "", // Don't include full content in response
		Format:             request.OutputFormat,
		VulnerabilityCount: len(remainingMatches),
		IgnoredCount:       len(ignoredMatches),
		Source:             request.Source,
		OutputFile:         request.OutputFile,
		SeverityBreakdown:  severityBreakdown,
		HighestSeverity:    highestSeverity,
		SecurityNotice:     securityNotice,
	}

	return response, nil
}

// initialiseVulnerabilityDatabase initialises and updates the Grype vulnerability database
func (t *VulnerabilityScanTool) initialiseVulnerabilityDatabase(logger *logrus.Logger) (vulnerability.Provider, string, error) {
	// Configure database distribution and installation
	// Use Grype's default configurations
	distributionConfig := distribution.DefaultConfig()
	installationConfig := installation.DefaultConfig(distributionConfig.ID)

	logger.Debug("Checking for vulnerability database")

	// Log configuration details
	dbDir := installationConfig.DBDirectoryPath()
	dbFile := installationConfig.DBFilePath()
	logger.WithField("db_dir", dbDir).WithField("db_file", dbFile).Info("Database configuration")

	// Check if database file exists
	if _, err := os.Stat(dbFile); err == nil {
		logger.Info("Database file exists, attempting to use it")
		// Try to load existing database first
		vulnerabilityProvider, dbCloser, err := grype.LoadVulnerabilityDB(distributionConfig, installationConfig, false)
		if err == nil {
			logger.Info("Successfully loaded existing database")
			if dbCloser != nil {
				logger.WithField("db_info", dbCloser).Debug("Existing database status")
			}
			return vulnerabilityProvider, "existing", nil
		}
		logger.WithError(err).Warn("Failed to load existing database, will try to download")
	} else {
		logger.WithField("db_path", dbFile).Info("Database file does not exist")
	}

	// Ensure database directory exists
	if err := os.MkdirAll(dbDir, 0700); err != nil {
		logger.WithError(err).Warn("Failed to create database directory")
	}

	// Always try to download/update database first to ensure we have latest data
	vulnerabilityProvider, dbCloser, err := grype.LoadVulnerabilityDB(distributionConfig, installationConfig, true)
	if err != nil {
		logger.WithError(err).Error("Failed to download vulnerability database")

		// Try fallback to existing database
		logger.Info("Attempting to use existing database as fallback...")
		vulnerabilityProvider, dbCloser, err = grype.LoadVulnerabilityDB(distributionConfig, installationConfig, false)
		if err != nil {
			return nil, "", fmt.Errorf("failed to load vulnerability database (download failed and no existing database found): %w", err)
		}
		logger.Info("Using existing vulnerability database")

		// Database status available for inspection if needed
		if dbCloser != nil {
			logger.WithField("db_info", dbCloser).Debug("Database fallback status")
		}

		return vulnerabilityProvider, "fallback", nil
	}

	logger.Info("Vulnerability database downloaded successfully")

	// Database status available for inspection if needed
	if dbCloser != nil {
		logger.WithField("db_info", dbCloser).Debug("Database download status")
	}

	return vulnerabilityProvider, "downloaded", nil
}

// filterFixedVulnerabilities filters matches to only include those with fixes available
func (t *VulnerabilityScanTool) filterFixedVulnerabilities(matches []match.Match) []match.Match {
	var fixedMatches []match.Match
	for _, m := range matches {
		if len(m.Vulnerability.Fix.Versions) > 0 || m.Vulnerability.Fix.State == "fixed" {
			fixedMatches = append(fixedMatches, m)
		}
	}
	return fixedMatches
}

// formatVulnerabilityResults formats the vulnerability results according to the requested format
func (t *VulnerabilityScanTool) formatVulnerabilityResults(matches []match.Match, outputFormat string, sbomData *sbom.SBOM) (string, error) {
	switch outputFormat {
	case "json":
		return t.formatJSONResults(matches, sbomData)
	case "table":
		return t.formatTableResults(matches)
	case "cyclonedx-json":
		return t.formatCycloneDXResults(matches)
	case "sarif":
		return t.formatSARIFResults(matches, sbomData)
	default:
		return "", fmt.Errorf("unsupported output format: %s", outputFormat)
	}
}

// getSeverity safely extracts severity from vulnerability metadata
func (t *VulnerabilityScanTool) getSeverity(m match.Match) string {
	if m.Vulnerability.Metadata != nil && m.Vulnerability.Metadata.Severity != "" {
		return strings.ToLower(m.Vulnerability.Metadata.Severity)
	}
	return "unknown"
}

// getDescription safely extracts description from vulnerability metadata
func (t *VulnerabilityScanTool) getDescription(m match.Match) string {
	if m.Vulnerability.Metadata != nil {
		return m.Vulnerability.Metadata.Description
	}
	return "No description available"
}

// getURLs safely extracts URLs from vulnerability metadata
func (t *VulnerabilityScanTool) getURLs(m match.Match) []string {
	if m.Vulnerability.Metadata != nil {
		return m.Vulnerability.Metadata.URLs
	}
	return nil
}

// analyseSeverities analyses the severity breakdown and finds the highest severity
func (t *VulnerabilityScanTool) analyseSeverities(matches []match.Match) (map[string]int, string) {
	severityBreakdown := map[string]int{
		"critical":   0,
		"high":       0,
		"medium":     0,
		"low":        0,
		"negligible": 0,
		"unknown":    0,
	}

	highestSeverity := "none"

	// Analyse actual vulnerability severities
	for _, m := range matches {
		severity := t.getSeverity(m)
		if severity != "unknown" {
			if count, exists := severityBreakdown[severity]; exists {
				severityBreakdown[severity] = count + 1
			} else {
				severityBreakdown["unknown"]++
			}

			// Update highest severity
			if highestSeverity == "none" || t.isHigherSeverity(severity, highestSeverity) {
				highestSeverity = severity
			}
		}
	}

	return severityBreakdown, highestSeverity
}

// isHigherSeverity compares two severity levels and returns true if the first is higher
func (t *VulnerabilityScanTool) isHigherSeverity(severity1, severity2 string) bool {
	severityOrder := map[string]int{
		"critical":   5,
		"high":       4,
		"medium":     3,
		"low":        2,
		"negligible": 1,
		"unknown":    0,
		"none":       0,
	}

	return severityOrder[severity1] > severityOrder[severity2]
}

// writeToFile writes content to the specified file path
func (t *VulnerabilityScanTool) writeToFile(filePath, content string) error {
	// Validate output file path for security - must be absolute
	if !filepath.IsAbs(filePath) {
		return fmt.Errorf("output file path must be absolute: %s", filePath)
	}

	// Prevent path traversal in output file
	cleanPath := filepath.Clean(filePath)
	if strings.Contains(cleanPath, "..") {
		return fmt.Errorf("invalid output path: contains path traversal elements")
	}

	// Create directory if it doesn't exist
	dir := filepath.Dir(cleanPath)
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	// Write content to file
	if err := os.WriteFile(cleanPath, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write file %s: %w", cleanPath, err)
	}

	return nil
}

// ProvideExtendedInfo provides detailed usage information for the vulnerability scan tool
// formatJSONResults formats vulnerability matches as JSON
func (t *VulnerabilityScanTool) formatJSONResults(matches []match.Match, sbomData *sbom.SBOM) (string, error) {
	vulnList := make([]map[string]interface{}, 0, len(matches))
	for _, m := range matches {
		vuln := map[string]interface{}{
			"id":          m.Vulnerability.ID,
			"severity":    t.getSeverity(m),
			"description": t.getDescription(m),
			"package": map[string]interface{}{
				"name":    m.Package.Name,
				"version": m.Package.Version,
				"type":    string(m.Package.Type),
			},
		}

		// Add fix information if available
		if len(m.Vulnerability.Fix.Versions) > 0 {
			vuln["fix"] = map[string]interface{}{
				"versions": m.Vulnerability.Fix.Versions,
				"state":    m.Vulnerability.Fix.State,
			}
		}

		// Add URLs if available
		urls := t.getURLs(m)
		if len(urls) > 0 {
			vuln["urls"] = urls
		}

		vulnList = append(vulnList, vuln)
	}

	severityBreakdown, _ := t.analyseSeverities(matches)

	result := map[string]interface{}{
		"vulnerability_report_format": "json",
		"vulnerabilities":             vulnList,
		"scan_metadata": map[string]interface{}{
			"vulnerability_count": len(matches),
			"severity_breakdown":  severityBreakdown,
			"timestamp":           time.Now().Format(time.RFC3339),
			"scanner":             "grype",
		},
	}

	jsonBytes, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal JSON: %w", err)
	}

	return string(jsonBytes), nil
}

// formatTableResults formats vulnerability matches as a human-readable table
func (t *VulnerabilityScanTool) formatTableResults(matches []match.Match) (string, error) {
	if len(matches) == 0 {
		return "No vulnerabilities found.\n", nil
	}

	var result strings.Builder
	result.WriteString(fmt.Sprintf("Found %d vulnerabilities:\n\n", len(matches)))
	result.WriteString(fmt.Sprintf("%-20s %-15s %-30s %-15s %s\n", "VULNERABILITY", "SEVERITY", "PACKAGE", "VERSION", "DESCRIPTION"))
	result.WriteString(strings.Repeat("-", 120) + "\n")

	for _, m := range matches {
		description := t.getDescription(m)
		if len(description) > 50 {
			description = description[:47] + "..."
		}

		result.WriteString(fmt.Sprintf("%-20s %-15s %-30s %-15s %s\n",
			m.Vulnerability.ID,
			strings.ToUpper(t.getSeverity(m)),
			m.Package.Name,
			m.Package.Version,
			description,
		))
	}

	return result.String(), nil
}

// formatCycloneDXResults formats vulnerability matches as CycloneDX JSON
func (t *VulnerabilityScanTool) formatCycloneDXResults(matches []match.Match) (string, error) {
	// Basic CycloneDX VDR (Vulnerability Disclosure Report) structure
	vulnerabilities := make([]map[string]any, 0, len(matches))
	for _, m := range matches {
		vuln := map[string]any{
			"id": m.Vulnerability.ID,
			"source": map[string]any{
				"name": "grype",
				"url":  "https://github.com/anchore/grype",
			},
			"ratings": []map[string]interface{}{
				{
					"severity": strings.ToUpper(t.getSeverity(m)),
					"method":   "CVSSv3",
				},
			},
			"description": t.getDescription(m),
			"affects": []map[string]interface{}{
				{
					"ref": fmt.Sprintf("pkg:%s/%s@%s", m.Package.Type, m.Package.Name, m.Package.Version),
				},
			},
		}
		vulnerabilities = append(vulnerabilities, vuln)
	}

	result := map[string]interface{}{
		"bomFormat":       "CycloneDX",
		"specVersion":     "1.4",
		"version":         1,
		"vulnerabilities": vulnerabilities,
		"metadata": map[string]interface{}{
			"timestamp": time.Now().Format(time.RFC3339),
			"tools": []map[string]interface{}{
				{
					"name":    "grype",
					"vendor":  "anchore",
					"version": "latest",
				},
			},
		},
	}

	jsonBytes, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal CycloneDX JSON: %w", err)
	}

	return string(jsonBytes), nil
}

// formatSARIFResults formats vulnerability matches as SARIF JSON
func (t *VulnerabilityScanTool) formatSARIFResults(matches []match.Match, sbomData *sbom.SBOM) (string, error) {
	rules := make([]map[string]any, 0)
	results := make([]map[string]any, 0, len(matches))

	ruleMap := make(map[string]bool)

	for _, m := range matches {
		// Add rule if not already present
		if !ruleMap[m.Vulnerability.ID] {
			rule := map[string]interface{}{
				"id":   m.Vulnerability.ID,
				"name": m.Vulnerability.ID,
				"shortDescription": map[string]interface{}{
					"text": fmt.Sprintf("Vulnerability %s", m.Vulnerability.ID),
				},
				"fullDescription": map[string]interface{}{
					"text": t.getDescription(m),
				},
				"help": map[string]interface{}{
					"text": fmt.Sprintf("Fix available: %v", len(m.Vulnerability.Fix.Versions) > 0),
				},
			}
			rules = append(rules, rule)
			ruleMap[m.Vulnerability.ID] = true
		}

		// Convert severity to SARIF level
		level := "note"
		switch t.getSeverity(m) {
		case "critical", "high":
			level = "error"
		case "medium":
			level = "warning"
		case "low", "negligible":
			level = "note"
		}

		result := map[string]interface{}{
			"ruleId": m.Vulnerability.ID,
			"level":  level,
			"message": map[string]interface{}{
				"text": fmt.Sprintf("Vulnerability %s found in %s@%s", m.Vulnerability.ID, m.Package.Name, m.Package.Version),
			},
			"locations": []map[string]interface{}{
				{
					"physicalLocation": map[string]interface{}{
						"artifactLocation": map[string]interface{}{
							"uri": fmt.Sprintf("pkg:%s/%s@%s", m.Package.Type, m.Package.Name, m.Package.Version),
						},
					},
				},
			},
		}
		results = append(results, result)
	}

	sarif := map[string]interface{}{
		"version": "2.1.0",
		"$schema": "https://json.schemastore.org/sarif-2.1.0.json",
		"runs": []map[string]interface{}{
			{
				"tool": map[string]interface{}{
					"driver": map[string]interface{}{
						"name":           "grype",
						"version":        "latest",
						"informationUri": "https://github.com/anchore/grype",
						"rules":          rules,
					},
				},
				"results": results,
			},
		},
	}

	jsonBytes, err := json.MarshalIndent(sarif, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal SARIF JSON: %w", err)
	}

	return string(jsonBytes), nil
}

func (t *VulnerabilityScanTool) ProvideExtendedInfo() *tools.ExtendedHelp {
	return &tools.ExtendedHelp{
		Examples: []tools.ToolExample{
			{
				Description: "Scan project for vulnerabilities",
				Arguments: map[string]any{
					"source": "/Users/user/my-project",
				},
				ExpectedResult: "JSON report of all vulnerabilities found in project dependencies",
			},
			{
				Description: "Scan SBOM file for vulnerabilities",
				Arguments: map[string]any{
					"source":        "sbom:/Users/user/project-sbom.json",
					"output_format": "sarif",
				},
				ExpectedResult: "SARIF format report suitable for IDE integration and security toolchain",
			},
			{
				Description: "Focus on fixable vulnerabilities only",
				Arguments: map[string]any{
					"source":      "/Users/user/my-app",
					"only_fixed":  true,
					"output_file": "/Users/user/reports/fixable-vulns.json",
				},
				ExpectedResult: "JSON report saved to file containing only vulnerabilities with available fixes",
			},
			{
				Description: "Analyse single package for vulnerabilities",
				Arguments: map[string]any{
					"source":        "pkg:npm/lodash@4.17.21",
					"output_format": "table",
				},
				ExpectedResult: "Human-readable table showing vulnerabilities in the specific lodash package version",
			},
		},
		CommonPatterns: []string{
			"Use SBOM workflow: generate SBOM first, then scan (sbom:/path/to/file.json) for faster repeated scans",
			"Use absolute paths for all file operations to ensure consistent behaviour",
			"Focus on only_fixed=true to get actionable vulnerability reports",
			"Use SARIF format for IDE integration and security toolchain compatibility",
			"Use table format for quick human review, JSON for programmatic analysis",
		},
		Troubleshooting: []tools.TroubleshootingTip{
			{
				Problem:  "No vulnerabilities found but expecting some",
				Solution: "Ensure the source contains package manager files or use a valid SBOM file. The tool needs dependency information to scan for vulnerabilities.",
			},
			{
				Problem:  "Path must be absolute error",
				Solution: "Use absolute paths for source and output_file parameters. Relative paths like '.' or './src' are not supported.",
			},
			{
				Problem:  "Too many vulnerabilities reported",
				Solution: "Use only_fixed=true to focus on actionable items with confirmed fixes available.",
			},
			{
				Problem:  "SBOM file not found or invalid format",
				Solution: "Ensure SBOM file exists at absolute path and is in supported format (Syft JSON, SPDX, CycloneDX). Generate with SBOM tool first.",
			},
		},
		ParameterDetails: map[string]string{
			"source":        "Source to scan: absolute directory path, SBOM file (sbom:/absolute/path.json), or package URL (pkg:npm/package@version). Directory scanning creates SBOM first.",
			"output_format": "Report format: 'json' (comprehensive data), 'table' (human readable), 'sarif' (IDE integration), 'cyclonedx-json' (toolchain integration).",
			"only_fixed":    "When true, only reports vulnerabilities with available fixes. Helps focus on actionable security issues.",
			"output_file":   "Optional: Save report to absolute file path. Creates directories as needed. When omitted, results are returned directly.",
		},
		WhenToUse:    "Use for security analysis during development, CI/CD security gates, compliance reporting, dependency risk assessment, and integration with security workflows.",
		WhenNotToUse: "Don't use for runtime vulnerability scanning (use dedicated runtime scanners), for container images without source code access, or when immediate results are critical (database updates can cause delays).",
	}
}
