package youtube

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"sync"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/sammcj/mcp-devtools/internal/registry"
	"github.com/sirupsen/logrus"
)

// YouTubeTool implements the tools.Tool interface for YouTube transcript extraction
type YouTubeTool struct {
	config *Config
}

// init registers the tool with the registry
func init() {
	// Load configuration at initialization time
	config := loadConfig()
	tool := &YouTubeTool{
		config: config,
	}
	registry.Register(tool)
}

// loadConfig loads configuration from environment variables at init time
func loadConfig() *Config {
	config := &Config{
		CacheEnabled:    true,
		CacheTTLMinutes: 60,
	}

	// Check cache enabled setting
	if cacheEnabled := os.Getenv("YOUTUBE_TRANSCRIPT_CACHE_ENABLED"); cacheEnabled != "" {
		if enabled, err := strconv.ParseBool(cacheEnabled); err == nil {
			config.CacheEnabled = enabled
		}
	}

	// Check cache TTL setting
	if cacheTTL := os.Getenv("YOUTUBE_TRANSCRIPT_CACHE_TTL_MINUTES"); cacheTTL != "" {
		if ttl, err := strconv.Atoi(cacheTTL); err == nil && ttl > 0 {
			config.CacheTTLMinutes = ttl
		}
	}

	// Check for YouTube API key
	config.YouTubeAPIKey = os.Getenv("YOUTUBE_API_KEY")

	return config
}

// SetConfig sets the configuration for the tool (used in testing)
func (t *YouTubeTool) SetConfig(config *Config) {
	t.config = config
}

// Definition returns the tool's definition for MCP registration
func (t *YouTubeTool) Definition() mcp.Tool {
	return mcp.NewTool(
		"youtube_transcript",
		mcp.WithDescription("Extract transcripts from YouTube videos with multiple output formats and language support"),
		mcp.WithString("video_url",
			mcp.Required(),
			mcp.Description("YouTube video URL or video ID"),
		),
		mcp.WithString("language",
			mcp.Description("Preferred language code (e.g., 'en-GB', 'en', 'fr'). Defaults to auto-detect with British English preference"),
			mcp.DefaultString("auto"),
		),
		mcp.WithString("format",
			mcp.Description("Output format for the transcript"),
			mcp.Enum("text", "json", "srt", "vtt"),
			mcp.DefaultString("text"),
		),
		mcp.WithBoolean("include_timestamps",
			mcp.Description("Include timing information in output"),
			mcp.DefaultBool(true),
		),
		mcp.WithBoolean("auto_generated_fallback",
			mcp.Description("Allow auto-generated captions if manual ones unavailable"),
			mcp.DefaultBool(true),
		),
		mcp.WithString("translate_to",
			mcp.Description("Translate transcript to specified language (optional)"),
		),
	)
}

// Execute executes the tool's logic
func (t *YouTubeTool) Execute(ctx context.Context, logger *logrus.Logger, cache *sync.Map, args map[string]interface{}) (*mcp.CallToolResult, error) {
	// Refresh API key at execution time to handle stdio mode issues
	if apiKey := os.Getenv("YOUTUBE_API_KEY"); apiKey != "" {
		t.config.YouTubeAPIKey = apiKey
	}

	// Parse and validate parameters
	videoURL, ok := args["video_url"].(string)
	if !ok || videoURL == "" {
		return nil, fmt.Errorf("missing required parameter: video_url")
	}

	language := "auto"
	if langRaw, ok := args["language"].(string); ok && langRaw != "" {
		language = langRaw
	}

	format := "text"
	if formatRaw, ok := args["format"].(string); ok && formatRaw != "" {
		format = formatRaw
	}

	includeTimestamps := true
	if timestampsRaw, ok := args["include_timestamps"].(bool); ok {
		includeTimestamps = timestampsRaw
	}

	autoGeneratedFallback := true
	if fallbackRaw, ok := args["auto_generated_fallback"].(bool); ok {
		autoGeneratedFallback = fallbackRaw
	}

	translateTo := ""
	if translateRaw, ok := args["translate_to"].(string); ok {
		translateTo = translateRaw
	}

	logger.WithFields(logrus.Fields{
		"video_url":               videoURL,
		"language":                language,
		"format":                  format,
		"include_timestamps":      includeTimestamps,
		"auto_generated_fallback": autoGeneratedFallback,
		"translate_to":            translateTo,
		"has_api_key":             t.config.YouTubeAPIKey != "",
	}).Info("Extracting YouTube transcript")

	// Extract video ID from URL
	videoID, err := ExtractVideoID(videoURL)
	if err != nil {
		return nil, fmt.Errorf("failed to extract video ID: %w", err)
	}

	// Check cache first
	cacheKey := fmt.Sprintf("youtube_transcript_%s_%s_%s_%t", videoID, language, format, includeTimestamps)
	if t.config.CacheEnabled {
		if cachedResult, ok := cache.Load(cacheKey); ok {
			if response, ok := cachedResult.(*TranscriptResponse); ok {
				logger.Info("Retrieved transcript from cache")
				return t.newToolResultJSON(response)
			}
		}
	}

	// Try extractors in order of preference: Official API -> Unofficial API
	var response *TranscriptResponse
	var extractErr error

	// Try official YouTube Data API v3 if API key is available
	if t.config.YouTubeAPIKey != "" {
		logger.WithField("api_key_length", len(t.config.YouTubeAPIKey)).Info("Attempting transcript extraction using YouTube Data API v3")
		officialExtractor := NewOfficialExtractor(t.config.YouTubeAPIKey, logger)
		response, extractErr = officialExtractor.ExtractTranscript(ctx, videoID, language, OutputFormat(format), includeTimestamps, autoGeneratedFallback, translateTo)
		if extractErr == nil {
			logger.Info("Successfully extracted transcript using official API")
		} else {
			logger.WithError(extractErr).Warn("Official API failed, falling back to unofficial method")
		}
	} else {
		logger.Info("No YouTube API key found, using unofficial API")
	}

	// Fallback to unofficial API if official failed or no API key
	if response == nil {
		logger.Info("Attempting transcript extraction using unofficial API")
		unofficialExtractor := NewUnofficialExtractor(logger)
		response, extractErr = unofficialExtractor.ExtractTranscript(ctx, videoID, language, OutputFormat(format), includeTimestamps, autoGeneratedFallback, translateTo)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract transcript: %w", extractErr)
		}
	}

	// Cache the result
	if t.config.CacheEnabled {
		cache.Store(cacheKey, response)
	}

	logger.WithFields(logrus.Fields{
		"video_id":          response.VideoID,
		"title":             response.Title,
		"language":          response.Language,
		"is_auto_generated": response.IsAutoGenerated,
		"extraction_method": response.Metadata.ExtractionMethod,
	}).Info("Successfully extracted transcript")

	return t.newToolResultJSON(response)
}

// newToolResultJSON creates a new tool result with JSON content
func (t *YouTubeTool) newToolResultJSON(data interface{}) (*mcp.CallToolResult, error) {
	jsonBytes, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("failed to marshal JSON: %w", err)
	}

	return mcp.NewToolResultText(string(jsonBytes)), nil
}
