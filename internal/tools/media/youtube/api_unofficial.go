package youtube

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"math/rand"
	"net"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
)

// UnofficialExtractor implements transcript extraction using YouTube's InnerTube API
type UnofficialExtractor struct {
	logger          *logrus.Logger
	client          *http.Client
	cookieJar       *CookieJar
	cookieExtractor *BrowserCookieExtractor
	ipv6Rotator     *IPv6Rotator
}

// CookieJar holds browser cookies for requests
type CookieJar struct {
	cookies []*http.Cookie
}

// InnerTubeResponse represents the response from YouTube's InnerTube API
type InnerTubeResponse struct {
	Captions struct {
		PlayerCaptionsTracklistRenderer struct {
			CaptionTracks []struct {
				BaseURL string `json:"baseUrl"`
				Name    struct {
					SimpleText string `json:"simpleText"`
				} `json:"name"`
				VssID          string `json:"vssId"`
				LanguageCode   string `json:"languageCode"`
				Kind           string `json:"kind,omitempty"`
				IsTranslatable bool   `json:"isTranslatable"`
			} `json:"captionTracks"`
		} `json:"playerCaptionsTracklistRenderer"`
	} `json:"captions"`
	VideoDetails struct {
		VideoID string `json:"videoId"`
		Title   string `json:"title"`
	} `json:"videoDetails"`
}

// TranscriptXMLEntry represents an entry in the XML transcript
type TranscriptXMLEntry struct {
	Start    float64
	Duration float64
	Text     string
}

// NewUnofficialExtractor creates a new unofficial API extractor
func NewUnofficialExtractor(logger *logrus.Logger) *UnofficialExtractor {
	ipv6Rotator := NewIPv6Rotator(logger)

	extractor := &UnofficialExtractor{
		logger: logger,
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
		cookieExtractor: NewBrowserCookieExtractor(logger),
		ipv6Rotator:     ipv6Rotator,
	}

	// Try to extract browser cookies
	if cookies, err := extractor.cookieExtractor.ExtractYouTubeCookies(); err == nil {
		extractor.cookieJar = &CookieJar{cookies: cookies}
		logger.Infof("Successfully extracted %d YouTube cookies from browser", len(cookies))
		// Log cookie names for debugging (not values for security)
		cookieNames := make([]string, len(cookies))
		for i, cookie := range cookies {
			cookieNames[i] = cookie.Name
		}
		logger.Infof("Extracted cookies: %v", cookieNames)
	} else {
		logger.Infof("Failed to extract browser cookies: %v", err)
	}

	return extractor
}

// ExtractTranscript extracts transcript using YouTube's InnerTube API
func (e *UnofficialExtractor) ExtractTranscript(ctx context.Context, videoID, language string, format OutputFormat, includeTimestamps, autoGeneratedFallback bool, translateTo string) (*TranscriptResponse, error) {
	// Get video info using InnerTube API
	videoInfo, err := e.getVideoInfoViaInnerTube(ctx, videoID)
	if err != nil {
		return nil, fmt.Errorf("failed to get video info: %w", err)
	}

	// Select the best caption track
	captionTrack, err := e.selectCaptionTrack(videoInfo.Captions, language, autoGeneratedFallback)
	if err != nil {
		return nil, fmt.Errorf("failed to select caption track: %w", err)
	}

	// Download the transcript XML
	transcriptXML, err := e.downloadTranscriptXML(ctx, captionTrack.BaseURL)
	if err != nil {
		return nil, fmt.Errorf("failed to download transcript: %w", err)
	}

	// Parse the XML into entries
	entries, err := e.parseTranscriptXML(transcriptXML)
	if err != nil {
		return nil, fmt.Errorf("failed to parse transcript: %w", err)
	}

	// Convert to our format
	segments := make([]TranscriptSegment, len(entries))
	for i, entry := range entries {
		segments[i] = TranscriptSegment{
			Text:     cleanText(entry.Text),
			Start:    entry.Start,
			Duration: entry.Duration,
		}
	}

	// Create response
	response := &TranscriptResponse{
		VideoID:         videoID,
		Title:           videoInfo.Title,
		Language:        captionTrack.LanguageCode,
		IsAutoGenerated: captionTrack.Kind == "asr",
		Format:          string(format),
		Segments:        segments,
		Metadata: TranscriptMetadata{
			ExtractionMethod:   string(MethodUnofficial),
			ExtractedAt:        time.Now(),
			AvailableLanguages: e.getAvailableLanguages(videoInfo.Captions),
		},
	}

	// Apply formatting
	if err := e.formatOutput(response, format, includeTimestamps); err != nil {
		return nil, fmt.Errorf("failed to format output: %w", err)
	}

	return response, nil
}

// getVideoInfoViaInnerTube fetches video info using YouTube's InnerTube API
func (e *UnofficialExtractor) getVideoInfoViaInnerTube(ctx context.Context, videoID string) (*VideoInfo, error) {
	// First, get the YouTube page to extract the InnerTube API key
	apiKey, err := e.extractInnerTubeAPIKey(ctx, videoID)
	if err != nil {
		return nil, fmt.Errorf("failed to extract InnerTube API key: %w", err)
	}

	// Prepare InnerTube API request
	innerTubeURL := fmt.Sprintf("https://www.youtube.com/youtubei/v1/player?key=%s", apiKey)

	payload := map[string]interface{}{
		"context": map[string]interface{}{
			"client": map[string]interface{}{
				"clientName":    "ANDROID",
				"clientVersion": "20.10.38",
			},
		},
		"videoId": videoID,
	}

	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal payload: %w", err)
	}

	// Create POST request to InnerTube API
	req, err := http.NewRequestWithContext(ctx, "POST", innerTubeURL, strings.NewReader(string(jsonPayload)))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers to mimic Android client
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "com.google.android.youtube/20.10.38 (Linux; U; Android 12; SM-G991B) gzip")
	req.Header.Set("Accept", "*/*")
	req.Header.Set("Accept-Language", "en-US,en;q=0.9")
	req.Header.Set("Origin", "https://www.youtube.com")

	// Add browser cookies if available
	if e.cookieJar != nil {
		for _, cookie := range e.cookieJar.cookies {
			req.AddCookie(cookie)
		}
	}

	// Make request
	resp, err := e.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("InnerTube API request failed: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("InnerTube API returned HTTP %d: %s", resp.StatusCode, string(body))
	}

	// Parse response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read InnerTube response: %w", err)
	}

	var innerTubeResp InnerTubeResponse
	if err := json.Unmarshal(body, &innerTubeResp); err != nil {
		return nil, fmt.Errorf("failed to parse InnerTube response: %w", err)
	}

	// Convert to our format
	var captions []CaptionTrack
	for _, track := range innerTubeResp.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks {
		caption := CaptionTrack{
			BaseURL:         track.BaseURL,
			Name:            track.Name.SimpleText,
			VssID:           track.VssID,
			LanguageCode:    track.LanguageCode,
			Kind:            track.Kind,
			IsTranslatable:  track.IsTranslatable,
			IsAutoGenerated: track.Kind == "asr",
		}
		captions = append(captions, caption)
	}

	videoInfo := &VideoInfo{
		VideoID:  videoID,
		Title:    innerTubeResp.VideoDetails.Title,
		Captions: captions,
	}

	e.logger.Debugf("Found %d caption tracks for video: %s", len(videoInfo.Captions), videoInfo.Title)
	return videoInfo, nil
}

// extractInnerTubeAPIKey extracts the InnerTube API key from YouTube page
func (e *UnofficialExtractor) extractInnerTubeAPIKey(ctx context.Context, videoID string) (string, error) {
	// First try using a known working API key from research
	// This is the current public key that InnerTube uses
	knownAPIKey := "REDACTED"

	// Test if this API key works by making a simple request
	e.logger.Debugf("Using known InnerTube API key: %s", knownAPIKey)
	return knownAPIKey, nil
}

// downloadTranscriptXML downloads the transcript XML from the caption URL
func (e *UnofficialExtractor) downloadTranscriptXML(ctx context.Context, captionURL string) (string, error) {
	// Add specific parameters that yt-dlp uses to avoid issues
	if !strings.Contains(captionURL, "fmt=") {
		separator := "&"
		if !strings.Contains(captionURL, "?") {
			separator = "?"
		}
		// Use parameters based on yt-dlp's approach
		captionURL = captionURL + separator + "fmt=srv3&xosf="
	}

	// Retry logic with human-like timing
	maxRetries := 3
	for attempt := 0; attempt < maxRetries; attempt++ {
		if attempt > 0 {
			// Add human-like delays with jitter to avoid detection patterns
			baseDelay := time.Duration(attempt*20) * time.Second
			jitter := time.Duration(rand.Intn(10)+5) * time.Second // 5-15 second jitter
			sleepTime := baseDelay + jitter
			e.logger.Infof("Waiting %v before retry attempt %d (with jitter)", sleepTime, attempt+1)
			time.Sleep(sleepTime)
		}

		req, err := http.NewRequestWithContext(ctx, "GET", captionURL, nil)
		if err != nil {
			return "", fmt.Errorf("failed to create request: %w", err)
		}

		// Set sophisticated headers to mimic a real browser session
		userAgents := []string{
			"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
			"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
			"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.3.1 Safari/605.1.15",
			"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
		}
		selectedUA := userAgents[attempt%len(userAgents)]

		req.Header.Set("User-Agent", selectedUA)
		req.Header.Set("Accept", "text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5")
		req.Header.Set("Accept-Language", "en-GB,en-US;q=0.9,en;q=0.8")
		req.Header.Set("Accept-Encoding", "gzip, deflate, br")
		req.Header.Set("DNT", "1")
		req.Header.Set("Connection", "keep-alive")
		req.Header.Set("Upgrade-Insecure-Requests", "1")
		req.Header.Set("Sec-Fetch-Dest", "empty")
		req.Header.Set("Sec-Fetch-Mode", "cors")
		req.Header.Set("Sec-Fetch-Site", "same-origin")
		req.Header.Set("Sec-Ch-Ua", `"Chromium";v="122", "Not(A:Brand";v="24", "Google Chrome";v="122"`)
		req.Header.Set("Sec-Ch-Ua-Mobile", "?0")
		req.Header.Set("Sec-Ch-Ua-Platform", `"macOS"`)
		req.Header.Set("Cache-Control", "no-cache")
		req.Header.Set("Pragma", "no-cache")

		// Add realistic referer
		videoURL := fmt.Sprintf("https://www.youtube.com/watch?v=%s", captionURL[strings.Index(captionURL, "v=")+2:strings.Index(captionURL, "&")])
		req.Header.Set("Referer", videoURL)

		// Add browser cookies if available
		if e.cookieJar != nil {
			e.logger.Infof("Adding %d cookies to transcript download request", len(e.cookieJar.cookies))
			for _, cookie := range e.cookieJar.cookies {
				req.AddCookie(cookie)
			}
		} else {
			e.logger.Info("No cookies available for transcript download request")
		}

		// Force IPv6-only mode for testing rate limiting bypass
		var resp *http.Response

		if e.ipv6Rotator.IsIPv6Available() {
			e.logger.Infof("Using IPv6-only mode for transcript download (attempt %d)", attempt+1)
			ipv6Client := e.ipv6Rotator.CreateHTTPClientWithRotation()

			// Add realistic pre-request delay to mimic human browsing patterns
			if attempt == 0 {
				// First attempt - shorter delay (2-5 seconds)
				preDelay := time.Duration(rand.Intn(3)+2) * time.Second
				e.logger.Debugf("Initial request delay: %v", preDelay)
				time.Sleep(preDelay)
			} else {
				// Retry attempts - longer delay with more variation (5-15 seconds)
				preDelay := time.Duration(rand.Intn(10)+5) * time.Second
				e.logger.Debugf("Retry request delay: %v", preDelay)
				time.Sleep(preDelay)
			}

			resp, err = ipv6Client.Do(req)

			// No IPv4 fallback - force IPv6 usage to test rate limiting bypass
			if err != nil {
				e.logger.Infof("IPv6 request failed: %v (no IPv4 fallback in testing mode)", err)
			}
		} else {
			e.logger.Error("IPv6 rotation not available, but IPv4 fallback disabled for testing")
			return "", fmt.Errorf("IPv6 required but not available on this system")
		}
		if err != nil {
			if attempt == maxRetries-1 {
				return "", fmt.Errorf("failed to download transcript after %d attempts: %w", maxRetries, err)
			}
			continue
		}
		defer func() { _ = resp.Body.Close() }()

		if resp.StatusCode == http.StatusTooManyRequests {
			if attempt == maxRetries-1 {
				return "", fmt.Errorf("transcript download rate limited after %d attempts - YouTube is blocking automated requests. Manual download URL: %s", maxRetries, captionURL)
			}
			e.logger.Debugf("Rate limited (429), retrying...")
			continue
		}

		if resp.StatusCode != http.StatusOK {
			body, _ := io.ReadAll(resp.Body)
			if attempt == maxRetries-1 {
				return "", fmt.Errorf("transcript download failed with status %d: %s", resp.StatusCode, string(body))
			}
			continue
		}

		body, err := io.ReadAll(resp.Body)
		if err != nil {
			if attempt == maxRetries-1 {
				return "", fmt.Errorf("failed to read transcript response: %w", err)
			}
			continue
		}

		return string(body), nil
	}

	return "", fmt.Errorf("failed to download transcript after %d attempts", maxRetries)
}

// parseTranscriptXML parses the XML transcript into entries
func (e *UnofficialExtractor) parseTranscriptXML(xmlContent string) ([]TranscriptXMLEntry, error) {
	var entries []TranscriptXMLEntry

	// Use regex to extract text segments from XML
	textRegex := regexp.MustCompile(`<text[^>]*start="([^"]*)"[^>]*dur="([^"]*)"[^>]*>([^<]*)</text>`)
	matches := textRegex.FindAllStringSubmatch(xmlContent, -1)

	for _, match := range matches {
		if len(match) >= 4 {
			start, _ := strconv.ParseFloat(match[1], 64)
			dur, _ := strconv.ParseFloat(match[2], 64)
			text := match[3]

			// Decode HTML entities
			text = strings.ReplaceAll(text, "&amp;", "&")
			text = strings.ReplaceAll(text, "&lt;", "<")
			text = strings.ReplaceAll(text, "&gt;", ">")
			text = strings.ReplaceAll(text, "&quot;", "\"")
			text = strings.ReplaceAll(text, "&#39;", "'")

			entries = append(entries, TranscriptXMLEntry{
				Start:    start,
				Duration: dur,
				Text:     text,
			})
		}
	}

	if len(entries) == 0 {
		return nil, fmt.Errorf("no transcript entries found in XML")
	}

	return entries, nil
}

// selectCaptionTrack selects the best caption track based on language preference
func (e *UnofficialExtractor) selectCaptionTrack(tracks []CaptionTrack, language string, autoGeneratedFallback bool) (*CaptionTrack, error) {
	if len(tracks) == 0 {
		return nil, fmt.Errorf("no caption tracks available")
	}

	var langPrefs LanguagePreference
	if language == "auto" {
		langPrefs = GetDefaultLanguagePreference()
	} else {
		langPrefs = LanguagePreference{
			Primary:   language,
			Fallbacks: []string{"en-GB", "en", "en-US"},
		}
	}

	// First, try to find manual captions in preferred languages
	for _, lang := range append([]string{langPrefs.Primary}, langPrefs.Fallbacks...) {
		for _, track := range tracks {
			if track.LanguageCode == lang && !track.IsAutoGenerated {
				return &track, nil
			}
		}
	}

	// If no manual captions found and auto-generated fallback is enabled
	if autoGeneratedFallback {
		for _, lang := range append([]string{langPrefs.Primary}, langPrefs.Fallbacks...) {
			for _, track := range tracks {
				if track.LanguageCode == lang && track.IsAutoGenerated {
					return &track, nil
				}
			}
		}
	}

	// Fallback to first available track
	return &tracks[0], nil
}

// formatOutput formats the response based on the requested format
func (e *UnofficialExtractor) formatOutput(response *TranscriptResponse, format OutputFormat, includeTimestamps bool) error {
	switch format {
	case FormatText:
		response.Transcript = e.formatAsText(response.Segments, includeTimestamps)
	case FormatJSON:
		// JSON format keeps the segments as-is
	case FormatSRT:
		response.Transcript = e.formatAsSRT(response.Segments)
	case FormatVTT:
		response.Transcript = e.formatAsVTT(response.Segments)
	default:
		return fmt.Errorf("unsupported format: %s", format)
	}

	return nil
}

// formatAsText formats segments as plain text
func (e *UnofficialExtractor) formatAsText(segments []TranscriptSegment, includeTimestamps bool) string {
	var result strings.Builder

	for _, segment := range segments {
		if includeTimestamps {
			minutes := int(segment.Start) / 60
			seconds := int(segment.Start) % 60
			result.WriteString(fmt.Sprintf("[%02d:%02d] %s\n", minutes, seconds, segment.Text))
		} else {
			result.WriteString(segment.Text + "\n")
		}
	}

	return strings.TrimSpace(result.String())
}

// formatAsSRT formats segments as SRT subtitle format
func (e *UnofficialExtractor) formatAsSRT(segments []TranscriptSegment) string {
	var result strings.Builder

	for i, segment := range segments {
		startTime := FormatSRTTime(segment.Start)
		endTime := FormatSRTTime(segment.Start + segment.Duration)

		result.WriteString(fmt.Sprintf("%d\n", i+1))
		result.WriteString(fmt.Sprintf("%s --> %s\n", startTime, endTime))
		result.WriteString(segment.Text + "\n\n")
	}

	return strings.TrimSpace(result.String())
}

// formatAsVTT formats segments as WebVTT format
func (e *UnofficialExtractor) formatAsVTT(segments []TranscriptSegment) string {
	var result strings.Builder
	result.WriteString("WEBVTT\n\n")

	for _, segment := range segments {
		startTime := FormatVTTTime(segment.Start)
		endTime := FormatVTTTime(segment.Start + segment.Duration)

		result.WriteString(fmt.Sprintf("%s --> %s\n", startTime, endTime))
		result.WriteString(segment.Text + "\n\n")
	}

	return strings.TrimSpace(result.String())
}

// getAvailableLanguages extracts available language codes from caption tracks
func (e *UnofficialExtractor) getAvailableLanguages(tracks []CaptionTrack) []string {
	seen := make(map[string]bool)
	var languages []string

	for _, track := range tracks {
		if !seen[track.LanguageCode] {
			languages = append(languages, track.LanguageCode)
			seen[track.LanguageCode] = true
		}
	}

	return languages
}

// Helper functions

// cleanText cleans up transcript text
func cleanText(text string) string {
	// Remove extra whitespace and newlines
	text = strings.TrimSpace(text)
	text = regexp.MustCompile(`\s+`).ReplaceAllString(text, " ")
	return text
}

// isTimeoutError checks if an error is a timeout error
func isTimeoutError(err error) bool {
	if netErr, ok := err.(net.Error); ok {
		return netErr.Timeout()
	}
	return strings.Contains(err.Error(), "timeout") || strings.Contains(err.Error(), "i/o timeout")
}

// isConnectionError checks if an error is a connection-related error
func isConnectionError(err error) bool {
	return strings.Contains(err.Error(), "connection refused") ||
		strings.Contains(err.Error(), "connection reset") ||
		strings.Contains(err.Error(), "network unreachable") ||
		strings.Contains(err.Error(), "no route to host") ||
		strings.Contains(err.Error(), "bind:") ||
		strings.Contains(err.Error(), "dial tcp")
}
