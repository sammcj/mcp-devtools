package youtube

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
)

// OfficialExtractor implements transcript extraction using YouTube Data API v3
type OfficialExtractor struct {
	apiKey string
	logger *logrus.Logger
	client *http.Client
}

// NewOfficialExtractor creates a new official API extractor
func NewOfficialExtractor(apiKey string, logger *logrus.Logger) *OfficialExtractor {
	return &OfficialExtractor{
		apiKey: apiKey,
		logger: logger,
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

// YouTubeCaptionListResponse represents the response from the captions.list API
type YouTubeCaptionListResponse struct {
	Items []YouTubeCaptionItem `json:"items"`
}

// YouTubeCaptionItem represents a caption track from the API
type YouTubeCaptionItem struct {
	ID      string                    `json:"id"`
	Snippet YouTubeCaptionItemSnippet `json:"snippet"`
}

// YouTubeCaptionItemSnippet contains caption metadata
type YouTubeCaptionItemSnippet struct {
	VideoID      string `json:"videoId"`
	Language     string `json:"language"`
	Name         string `json:"name"`
	TrackKind    string `json:"trackKind"`
	AudioTrack   bool   `json:"audioTrack"`
	IsCC         bool   `json:"isCC"`
	IsLarge      bool   `json:"isLarge"`
	IsEasyReader bool   `json:"isEasyReader"`
	IsDraft      bool   `json:"isDraft"`
	IsAutoSynced bool   `json:"isAutoSynced"`
}

// YouTubeVideoResponse represents video details from the API
type YouTubeVideoResponse struct {
	Items []YouTubeVideoItem `json:"items"`
}

// YouTubeVideoItem represents a video from the API
type YouTubeVideoItem struct {
	ID      string                  `json:"id"`
	Snippet YouTubeVideoItemSnippet `json:"snippet"`
}

// YouTubeVideoItemSnippet contains video metadata
type YouTubeVideoItemSnippet struct {
	Title string `json:"title"`
}

// ExtractTranscript extracts transcript using YouTube Data API v3
func (e *OfficialExtractor) ExtractTranscript(ctx context.Context, videoID, language string, format OutputFormat, includeTimestamps, autoGeneratedFallback bool, translateTo string) (*TranscriptResponse, error) {
	// Get video details
	videoTitle, err := e.getVideoTitle(ctx, videoID)
	if err != nil {
		return nil, fmt.Errorf("failed to get video title: %w", err)
	}

	// List available captions
	captions, err := e.listCaptions(ctx, videoID)
	if err != nil {
		return nil, fmt.Errorf("failed to list captions: %w", err)
	}

	if len(captions) == 0 {
		return nil, fmt.Errorf("no captions available for this video")
	}

	// Select the best caption track
	selectedCaption, err := e.selectBestCaption(captions, language, autoGeneratedFallback)
	if err != nil {
		return nil, fmt.Errorf("failed to select caption: %w", err)
	}

	// Download the caption content
	captionContent, err := e.downloadCaption(ctx, selectedCaption.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to download caption: %w", err)
	}

	// Parse the SRT content into segments
	segments, err := e.parseSRTContent(captionContent)
	if err != nil {
		return nil, fmt.Errorf("failed to parse caption content: %w", err)
	}

	// Create response
	response := &TranscriptResponse{
		VideoID:         videoID,
		Title:           videoTitle,
		Language:        selectedCaption.Snippet.Language,
		IsAutoGenerated: selectedCaption.Snippet.TrackKind == "ASR",
		Format:          string(format),
		Segments:        segments,
		Metadata: TranscriptMetadata{
			ExtractionMethod:   string(MethodOfficial),
			ExtractedAt:        time.Now(),
			AvailableLanguages: e.getAvailableLanguages(captions),
		},
	}

	// Apply formatting
	if err := e.formatOutput(response, format, includeTimestamps); err != nil {
		return nil, fmt.Errorf("failed to format output: %w", err)
	}

	return response, nil
}

// getVideoTitle retrieves the video title using the YouTube Data API
func (e *OfficialExtractor) getVideoTitle(ctx context.Context, videoID string) (string, error) {
	apiURL := fmt.Sprintf("https://www.googleapis.com/youtube/v3/videos?part=snippet&id=%s&key=%s", videoID, e.apiKey)

	req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := e.client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to make request: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	var videoResponse YouTubeVideoResponse
	if err := json.NewDecoder(resp.Body).Decode(&videoResponse); err != nil {
		return "", fmt.Errorf("failed to decode response: %w", err)
	}

	if len(videoResponse.Items) == 0 {
		return "", fmt.Errorf("video not found")
	}

	return videoResponse.Items[0].Snippet.Title, nil
}

// listCaptions retrieves available captions for a video
func (e *OfficialExtractor) listCaptions(ctx context.Context, videoID string) ([]YouTubeCaptionItem, error) {
	apiURL := fmt.Sprintf("https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=%s&key=%s", videoID, e.apiKey)

	req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := e.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	var captionsResponse YouTubeCaptionListResponse
	if err := json.NewDecoder(resp.Body).Decode(&captionsResponse); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	e.logger.Debugf("Found %d caption tracks", len(captionsResponse.Items))
	return captionsResponse.Items, nil
}

// selectBestCaption selects the best available caption based on language preference
func (e *OfficialExtractor) selectBestCaption(captions []YouTubeCaptionItem, language string, autoGeneratedFallback bool) (*YouTubeCaptionItem, error) {
	if len(captions) == 0 {
		return nil, fmt.Errorf("no captions available")
	}

	var langPrefs LanguagePreference
	if language == "auto" {
		langPrefs = GetDefaultLanguagePreference()
	} else {
		langPrefs = LanguagePreference{
			Primary:   language,
			Fallbacks: []string{"en-GB", "en", "en-US"},
		}
	}

	// First, try to find manual captions in preferred languages
	for _, lang := range append([]string{langPrefs.Primary}, langPrefs.Fallbacks...) {
		for _, caption := range captions {
			if caption.Snippet.Language == lang && caption.Snippet.TrackKind != "ASR" {
				return &caption, nil
			}
		}
	}

	// If no manual captions found and auto-generated fallback is enabled
	if autoGeneratedFallback {
		for _, lang := range append([]string{langPrefs.Primary}, langPrefs.Fallbacks...) {
			for _, caption := range captions {
				if caption.Snippet.Language == lang && caption.Snippet.TrackKind == "ASR" {
					return &caption, nil
				}
			}
		}
	}

	// Fallback to first available caption
	return &captions[0], nil
}

// downloadCaption downloads the caption content
func (e *OfficialExtractor) downloadCaption(ctx context.Context, captionID string) (string, error) {
	// Download as SRT format
	apiURL := fmt.Sprintf("https://www.googleapis.com/youtube/v3/captions/%s?key=%s&tfmt=srt", captionID, e.apiKey)

	req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := e.client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to make request: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		if resp.StatusCode == http.StatusForbidden {
			return "", fmt.Errorf("caption download forbidden - this may be due to video owner restrictions or missing permissions")
		}
		return "", fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %w", err)
	}

	return string(body), nil
}

// parseSRTContent parses SRT format content into transcript segments
func (e *OfficialExtractor) parseSRTContent(content string) ([]TranscriptSegment, error) {
	lines := strings.Split(content, "\n")
	var segments []TranscriptSegment

	i := 0
	for i < len(lines) {
		// Skip empty lines
		if strings.TrimSpace(lines[i]) == "" {
			i++
			continue
		}

		// Skip sequence number
		if _, err := strconv.Atoi(strings.TrimSpace(lines[i])); err == nil {
			i++
		}

		// Parse timing line
		if i >= len(lines) {
			break
		}

		timingLine := strings.TrimSpace(lines[i])
		if strings.Contains(timingLine, "-->") {
			start, duration, err := e.parseSRTTiming(timingLine)
			if err != nil {
				e.logger.Debugf("Failed to parse timing: %s", timingLine)
				i++
				continue
			}

			// Collect text lines until empty line or end
			var textLines []string
			i++
			for i < len(lines) && strings.TrimSpace(lines[i]) != "" {
				textLines = append(textLines, strings.TrimSpace(lines[i]))
				i++
			}

			if len(textLines) > 0 {
				text := strings.Join(textLines, " ")
				segments = append(segments, TranscriptSegment{
					Text:     text,
					Start:    start,
					Duration: duration,
				})
			}
		} else {
			i++
		}
	}

	return segments, nil
}

// parseSRTTiming parses SRT timing format "00:00:01,500 --> 00:00:04,000"
func (e *OfficialExtractor) parseSRTTiming(timingLine string) (float64, float64, error) {
	parts := strings.Split(timingLine, " --> ")
	if len(parts) != 2 {
		return 0, 0, fmt.Errorf("invalid timing format")
	}

	start, err := e.parseSRTTime(strings.TrimSpace(parts[0]))
	if err != nil {
		return 0, 0, fmt.Errorf("failed to parse start time: %w", err)
	}

	end, err := e.parseSRTTime(strings.TrimSpace(parts[1]))
	if err != nil {
		return 0, 0, fmt.Errorf("failed to parse end time: %w", err)
	}

	duration := end - start
	return start, duration, nil
}

// parseSRTTime parses SRT time format "00:00:01,500"
func (e *OfficialExtractor) parseSRTTime(timeStr string) (float64, error) {
	// Replace comma with dot for milliseconds
	timeStr = strings.ReplaceAll(timeStr, ",", ".")

	parts := strings.Split(timeStr, ":")
	if len(parts) != 3 {
		return 0, fmt.Errorf("invalid time format")
	}

	hours, err := strconv.ParseFloat(parts[0], 64)
	if err != nil {
		return 0, fmt.Errorf("invalid hours: %w", err)
	}

	minutes, err := strconv.ParseFloat(parts[1], 64)
	if err != nil {
		return 0, fmt.Errorf("invalid minutes: %w", err)
	}

	seconds, err := strconv.ParseFloat(parts[2], 64)
	if err != nil {
		return 0, fmt.Errorf("invalid seconds: %w", err)
	}

	totalSeconds := hours*3600 + minutes*60 + seconds
	return totalSeconds, nil
}

// getAvailableLanguages extracts available language codes from captions
func (e *OfficialExtractor) getAvailableLanguages(captions []YouTubeCaptionItem) []string {
	seen := make(map[string]bool)
	var languages []string

	for _, caption := range captions {
		if !seen[caption.Snippet.Language] {
			languages = append(languages, caption.Snippet.Language)
			seen[caption.Snippet.Language] = true
		}
	}

	return languages
}

// formatOutput formats the response based on the requested format
func (e *OfficialExtractor) formatOutput(response *TranscriptResponse, format OutputFormat, includeTimestamps bool) error {
	switch format {
	case FormatText:
		response.Transcript = e.formatAsText(response.Segments, includeTimestamps)
	case FormatJSON:
		// JSON format keeps the segments as-is
	case FormatSRT:
		response.Transcript = e.formatAsSRT(response.Segments)
	case FormatVTT:
		response.Transcript = e.formatAsVTT(response.Segments)
	default:
		return fmt.Errorf("unsupported format: %s", format)
	}

	return nil
}

// formatAsText formats segments as plain text
func (e *OfficialExtractor) formatAsText(segments []TranscriptSegment, includeTimestamps bool) string {
	var result strings.Builder

	for _, segment := range segments {
		if includeTimestamps {
			minutes := int(segment.Start) / 60
			seconds := int(segment.Start) % 60
			result.WriteString(fmt.Sprintf("[%02d:%02d] %s\n", minutes, seconds, segment.Text))
		} else {
			result.WriteString(segment.Text + "\n")
		}
	}

	return strings.TrimSpace(result.String())
}

// formatAsSRT formats segments as SRT subtitle format
func (e *OfficialExtractor) formatAsSRT(segments []TranscriptSegment) string {
	var result strings.Builder

	for i, segment := range segments {
		startTime := FormatSRTTime(segment.Start)
		endTime := FormatSRTTime(segment.Start + segment.Duration)

		result.WriteString(fmt.Sprintf("%d\n", i+1))
		result.WriteString(fmt.Sprintf("%s --> %s\n", startTime, endTime))
		result.WriteString(segment.Text + "\n\n")
	}

	return strings.TrimSpace(result.String())
}

// formatAsVTT formats segments as WebVTT format
func (e *OfficialExtractor) formatAsVTT(segments []TranscriptSegment) string {
	var result strings.Builder
	result.WriteString("WEBVTT\n\n")

	for _, segment := range segments {
		startTime := FormatVTTTime(segment.Start)
		endTime := FormatVTTTime(segment.Start + segment.Duration)

		result.WriteString(fmt.Sprintf("%s --> %s\n", startTime, endTime))
		result.WriteString(segment.Text + "\n\n")
	}

	return strings.TrimSpace(result.String())
}

// FormatSRTTime formats time in SRT format (HH:MM:SS,mmm)
func FormatSRTTime(seconds float64) string {
	hours := int(seconds) / 3600
	minutes := (int(seconds) % 3600) / 60
	secs := int(seconds) % 60
	milliseconds := int((seconds - float64(int(seconds))) * 1000)

	return fmt.Sprintf("%02d:%02d:%02d,%03d", hours, minutes, secs, milliseconds)
}

// FormatVTTTime formats time in WebVTT format (HH:MM:SS.mmm)
func FormatVTTTime(seconds float64) string {
	hours := int(seconds) / 3600
	minutes := (int(seconds) % 3600) / 60
	secs := int(seconds) % 60
	milliseconds := int((seconds - float64(int(seconds))) * 1000)

	return fmt.Sprintf("%02d:%02d:%02d.%03d", hours, minutes, secs, milliseconds)
}
