package generatechangelog

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/anchore/chronicle/chronicle/release"
	"github.com/anchore/chronicle/chronicle/release/change"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// formatAsMarkdown formats the changelog as markdown
func (t *GenerateChangelogTool) formatAsMarkdown(description *release.Description, title string) (string, error) {
	var buf bytes.Buffer

	// Write title
	fmt.Fprintf(&buf, "# %s\n\n", title)

	// Write version and date information
	version := description.Version
	if version == "" {
		version = "Unreleased"
	}

	dateStr := description.Date.Format("2006-01-02")
	fmt.Fprintf(&buf, "## %s - %s\n\n", version, dateStr)

	// Write repository information if available
	if description.VCSReferenceURL != "" {
		fmt.Fprintf(&buf, "**Repository**: %s  \n", description.VCSReferenceURL)
	}
	if description.VCSChangesURL != "" {
		fmt.Fprintf(&buf, "**Changes**: %s  \n", description.VCSChangesURL)
	}
	if description.VCSReferenceURL != "" || description.VCSChangesURL != "" {
		buf.WriteString("\n")
	}

	// Group changes by type
	changesByType := make(map[string][]change.Change)
	for _, ch := range description.Changes {
		// Get the first change type, or "unknown" if none
		changeType := "unknown"
		if len(ch.ChangeTypes) > 0 {
			changeType = ch.ChangeTypes[0].Name
		}
		changesByType[changeType] = append(changesByType[changeType], ch)
	}

	// Define the order of change types for better presentation
	typeOrder := []string{
		"breaking-feature",
		"security-fixes",
		"added-feature",
		"bug-fix",
		"deprecated-feature",
		"removed-feature",
		"unknown",
	}

	// Map change types to readable titles
	typeTitles := map[string]string{
		"breaking-feature":   "Breaking Changes",
		"security-fixes":     "Security Fixes",
		"added-feature":      "Added Features",
		"bug-fix":            "Bug Fixes",
		"deprecated-feature": "Deprecated Features",
		"removed-feature":    "Removed Features",
		"unknown":            "Additional Changes",
	}

	// Write changes grouped by type
	hasContent := false
	for _, changeType := range typeOrder {
		changes, exists := changesByType[changeType]
		if !exists || len(changes) == 0 {
			continue
		}

		title, titleExists := typeTitles[changeType]
		if !titleExists {
			title = cases.Title(language.English).String(strings.ReplaceAll(changeType, "-", " "))
		}

		fmt.Fprintf(&buf, "### %s\n\n", title)

		for _, change := range changes {
			t.writeChangeAsMarkdown(&buf, change)
		}
		buf.WriteString("\n")
		hasContent = true
	}

	// Handle any other change types not in our predefined list
	for changeType, changes := range changesByType {
		if contains(typeOrder, changeType) {
			continue // Already processed
		}

		title := cases.Title(language.English).String(strings.ReplaceAll(changeType, "-", " "))
		fmt.Fprintf(&buf, "### %s\n\n", title)

		for _, change := range changes {
			t.writeChangeAsMarkdown(&buf, change)
		}
		buf.WriteString("\n")
		hasContent = true
	}

	// Add footer if we have content
	if hasContent {
		buf.WriteString("---\n")
		buf.WriteString("*Generated by MCP DevTools generate_changelog tool*\n")
	} else {
		buf.WriteString("*No changes found in the specified range.*\n\n")
		buf.WriteString("---\n")
		buf.WriteString("*Generated by MCP DevTools generate_changelog tool*\n")
	}

	return buf.String(), nil
}

// writeChangeAsMarkdown writes a single change as markdown
func (t *GenerateChangelogTool) writeChangeAsMarkdown(buf *bytes.Buffer, ch change.Change) {
	// Start with bullet point
	buf.WriteString("- ")

	// Write the change text
	buf.WriteString(ch.Text)

	// Add additional information if available
	var details []string

	// For local git changes, we can extract info from References if available
	for _, ref := range ch.References {
		if ref.URL != "" {
			details = append(details, fmt.Sprintf("[%s](%s)", ref.Text, ref.URL))
		} else if ref.Text != "" {
			details = append(details, ref.Text)
		}
	}

	if len(details) > 0 {
		fmt.Fprintf(buf, " (%s)", strings.Join(details, ", "))
	}

	buf.WriteString("\n")
}

// formatAsJSON formats the changelog as JSON
func (t *GenerateChangelogTool) formatAsJSON(description *release.Description) (string, error) {
	// Create a structured JSON representation
	jsonData := map[string]interface{}{
		"title":       "Changelog",
		"version":     description.Version,
		"date":        description.Date.Format("2006-01-02"),
		"timestamp":   description.Date,
		"repository":  description.VCSReferenceURL,
		"changes_url": description.VCSChangesURL,
		"summary": map[string]interface{}{
			"total_changes": len(description.Changes),
		},
		"sections": t.groupChangesForJSON(description.Changes),
		"metadata": map[string]interface{}{
			"generator": "MCP DevTools generate_changelog",
			"generated": time.Now(),
		},
	}

	// Marshal to JSON with proper formatting
	jsonBytes, err := json.MarshalIndent(jsonData, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal changelog to JSON: %w", err)
	}

	return string(jsonBytes), nil
}

// groupChangesForJSON groups changes by type for JSON output
func (t *GenerateChangelogTool) groupChangesForJSON(changes []change.Change) []map[string]interface{} {
	// Group changes by type
	changesByType := make(map[string][]change.Change)
	for _, ch := range changes {
		// Get the first change type, or "unknown" if none
		changeType := "unknown"
		if len(ch.ChangeTypes) > 0 {
			changeType = ch.ChangeTypes[0].Name
		}
		changesByType[changeType] = append(changesByType[changeType], ch)
	}

	// Map change types to readable titles
	typeTitles := map[string]string{
		"breaking-feature":   "Breaking Changes",
		"security-fixes":     "Security Fixes",
		"added-feature":      "Added Features",
		"bug-fix":            "Bug Fixes",
		"deprecated-feature": "Deprecated Features",
		"removed-feature":    "Removed Features",
		"unknown":            "Additional Changes",
	}

	// Create sections
	var sections []map[string]interface{}

	// Define order for consistent output
	typeOrder := []string{
		"breaking-feature",
		"security-fixes",
		"added-feature",
		"bug-fix",
		"deprecated-feature",
		"removed-feature",
		"unknown",
	}

	// Process changes in order
	for _, changeType := range typeOrder {
		typeChanges, exists := changesByType[changeType]
		if !exists || len(typeChanges) == 0 {
			continue
		}

		title, titleExists := typeTitles[changeType]
		if !titleExists {
			title = cases.Title(language.English).String(strings.ReplaceAll(changeType, "-", " "))
		}

		// Convert changes to JSON format
		var jsonChanges []map[string]interface{}
		for _, ch := range typeChanges {
			changeType := "unknown"
			if len(ch.ChangeTypes) > 0 {
				changeType = ch.ChangeTypes[0].Name
			}

			jsonChange := map[string]interface{}{
				"text":      ch.Text,
				"type":      changeType,
				"timestamp": ch.Timestamp,
			}

			// Add references if available
			if len(ch.References) > 0 {
				var refs []map[string]string
				for _, ref := range ch.References {
					refs = append(refs, map[string]string{
						"text": ref.Text,
						"url":  ref.URL,
					})
				}
				jsonChange["references"] = refs
			}

			jsonChanges = append(jsonChanges, jsonChange)
		}

		section := map[string]interface{}{
			"type":    changeType,
			"title":   title,
			"count":   len(typeChanges),
			"changes": jsonChanges,
		}
		sections = append(sections, section)
	}

	// Handle any remaining change types
	for changeType, typeChanges := range changesByType {
		if contains(typeOrder, changeType) {
			continue
		}

		title := cases.Title(language.English).String(strings.ReplaceAll(changeType, "-", " "))

		var jsonChanges []map[string]interface{}
		for _, ch := range typeChanges {
			changeType := "unknown"
			if len(ch.ChangeTypes) > 0 {
				changeType = ch.ChangeTypes[0].Name
			}

			jsonChange := map[string]interface{}{
				"text":      ch.Text,
				"type":      changeType,
				"timestamp": ch.Timestamp,
			}

			// Add references if available
			if len(ch.References) > 0 {
				var refs []map[string]string
				for _, ref := range ch.References {
					refs = append(refs, map[string]string{
						"text": ref.Text,
						"url":  ref.URL,
					})
				}
				jsonChange["references"] = refs
			}

			jsonChanges = append(jsonChanges, jsonChange)
		}

		section := map[string]interface{}{
			"type":    changeType,
			"title":   title,
			"count":   len(typeChanges),
			"changes": jsonChanges,
		}
		sections = append(sections, section)
	}

	return sections
}

// contains checks if a slice contains a string
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
